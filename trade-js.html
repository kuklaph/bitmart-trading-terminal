<script>
  //On Start
  $(document).ready(async () => {
    //Start
    TradeUtility.Page.addEventListeners();
    App.init();
  });

  const App = {
    init: async () => {
      Markets.init();
      Stats.init();
      TradingviewChart.init();
      TradeHistory.init();
      OrderBook.init();

      const apiExists = await Terminal.checkAPI();
      if (apiExists) {
        Orders.updateCounter();
        setInterval(Orders.updateInterval, 60000);
      }
    },
    update: () => {
      Stats.init();
      TradingviewChart.init();
      Terminal.init();
      TradeHistory.init();
      OrderBook.init();
    },
  };
  // cCurrent
  const Current = {
    Symbol: {
      is: "BTC_USDT",
      step: 60,
      quote: "USDT",
      base: "BTC",
      stats: {
        change: "",
        open: "",
        high: "",
        low: "",
        price: "",
        vol: "",
      },
    },
    Nav: {
      selectedFilter: "USDT",
      filteredSymbols: {},
      sortedSymbols: [],
      sort: { by: "Market", isAsc: true },
      searchWord: "",
    },
    Favorites: [],
    Chart: {
      Candles: {
        kline: [],
        sets: 1,
      },
      Html: {
        instance: null,
        series: null,
      },
      Lines: {
        showActive: true,
        showSymbol: true,
        showSize: true,
        screenshotMode: false,
        showTp: false,
      },
      Markers: {
        show: true,
        showPrices: false,
      },
    },
    Orders: {
      nav: "viewActiveOrders",
      open: [],
      closed: [],
      wallets: [],
      isCanceling: false,
    },
    Terminal: {
      category: "simple",
      wallet: {
        buy: 0,
        sell: 0,
      },
      orders: [],
      Validation: {
        minQuoteBuyAmount: "5",
        minQuoteSellAmount: "5",
        minBaseSize: "0.00001",
        priceMinPrecision: -1,
        priceMaxPrecision: 2,
        minQuoteLadder: 0,
        minBaseLadder: 0,
        precision: "0.01",
        step: "0.00001",
      },
    },
    History: {
      lastTrade: null,
    },
    OrderBook: {
      created: false,
    },
  };

  // Markets ===========================
  // cMarkets
  const marketsList = document.getElementsByClassName("marketsList");
  const marketsListSm = document.getElementById("marketsListSm");
  const marketsListLg = document.getElementById("marketsListLg");
  const marketsNav = document.getElementById("marketsNav");
  const searchMarketsLg = document.getElementById("searchMarketsLg");
  const searchMarketsInput =
    document.getElementsByClassName("searchMarketsInput");
  const selectMarketQuote =
    document.getElementsByClassName("selectMarketQuote");
  const chooseChartStep = document.getElementsByClassName("chooseChartStep");
  const chooseCandleSets = document.getElementsByClassName("chooseCandleSets");
  const focusSearch = document.getElementById("focusSearch");
  const focusSearchBase = document.getElementsByClassName("focusSearchBase");
  const focusSearchQuote = document.getElementsByClassName("focusSearchQuote");
  const focusSearchName = document.getElementsByClassName("focusSearchName");
  const Markets = {
    init: () => {
      Markets.Nav.User.SelectNavPage.setActive();
      Markets.Load.withRequest();
      Markets.Load.savedFavorites();
    },
    allSymbols: [],
    Nav: {
      User: {
        focus: (event) => {
          searchMarketsLg.focus();
          searchMarketsLg.select();
        },
        input: (event) => {
          const { allSymbols } = Markets;
          if (!allSymbols.length) {
            return;
          }
          let word = "";
          for (const w of searchMarketsInput) {
            if (w.value) {
              word = w.value.trim();
            }
          }
          if (!word.length) {
            Markets.Load.withStored();
            return;
          }
          Current.Nav.searchWord = word.toUpperCase();
          Markets.Load.withStored(true);
        },
        clickNavList: (event) => {
          if (
            event.target.id == "marketsListSm" ||
            event.target.id == "marketsListLg"
          ) {
            return;
          }
          if (event.target.className.includes("addFav")) {
            Markets.Nav.User.addFav(event);
            return;
          }
          if (event.target.className.includes("removeFav")) {
            Markets.Nav.User.removeFav(event);
            return;
          }
          const { is } = Current.Symbol;
          let selected;
          if (event.target.className.includes("chooseSymbol")) {
            const target = event.target;
            const { base, quote, name, symbol } = target.dataset;
            selected = symbol;
            if (is == symbol) {
              return;
            }
            const lists = [marketsListLg, marketsListSm];
            for (const l of lists) {
              const { children } = l;
              for (const c of children) {
                c.setAttribute("class", "list-group-item py-0");
              }
            }
            const selectedId = document.getElementsByClassName(
              `.choose_${symbol}`
            );
            document
              .getElementById(`choose_sm_${symbol}`)
              .setAttribute("class", "list-group-item py-0 active");
            document
              .getElementById(`choose_lg_${symbol}`)
              .setAttribute("class", "list-group-item py-0 active");

            TradeUtility.HTML.setText(focusSearchBase, base);
            TradeUtility.HTML.setText(focusSearchQuote, quote);
            TradeUtility.HTML.setText(focusSearchName, name);
            Current.Symbol.is = symbol;
            Current.Symbol.quote = quote;
            Current.Symbol.base = base;
          }
          if (is == selected) {
            return;
          }
          Terminal.Form.Util.clear();
          for (const s of currentSymbol) {
            s.value = selected;
          }
          App.update();
        },
        addFav: (event) => {
          const symbol = event.target.dataset.symbol;
          const newFav = {
            S: symbol,
            URL: "https://www.bitmart.com/trade/en?layout=pro&symbol=" + symbol,
          };
          const [exists] = Current.Favorites.filter((f) => {
            return f.S == symbol;
          });
          if (!exists) {
            Current.Favorites.push(newFav);
            Utility.Server.run()
              .withSuccessHandler((result) => {
                if (result) {
                  Markets.Nav.User.swapFavButtons(true, event);
                }
              })
              .withFailureHandler((err) => {
                const removed = Current.Favorites.filter((f) => {
                  return f.S !== symbol;
                });
                Current.Favorites = removed;
                TradeUtility.Page.errResponses(err);
              })
              .saveFavLinks(Current.Favorites);
          }
        },
        removeFav: (event) => {
          const symbol = event.target.dataset.symbol;
          const removed = Current.Favorites.filter((f) => {
            return f.S !== symbol;
          });
          Utility.Server.run()
            .withSuccessHandler((result) => {
              if (result) {
                Current.Favorites = removed;
                Markets.Nav.User.swapFavButtons(false, event);
              }
            })
            .withFailureHandler((err) => {
              TradeUtility.Page.errResponses(err);
            })
            .saveFavLinks(removed);
        },
        swapFavButtons: (isAdd, event) => {
          const symbol = event.target.dataset.symbol;
          const parent = event.target.parentElement;
          let favButton, list;
          if (isAdd) {
            favButton = `<button type="button" data-symbol="${symbol}" class="btn btn-sm btn-outline-danger px-0 no-focus removeFav">~</button>`;
            list = document.getElementsByClassName("addFav");
          } else {
            favButton = `<button type="button" data-symbol="${symbol}" class="btn btn-sm btn-outline-primary px-0 no-focus addFav">+</button>`;
            list = document.getElementsByClassName("removeFav");
          }
          for (const i of list) {
            if (i.dataset.symbol == symbol) {
              i.parentElement.innerHTML = favButton;
            }
          }
          let search = "";
          for (const s of searchMarketsInput) {
            if (s.value) {
              search = s.value;
            }
          }
          Markets.Load.withStored(search.length ? true : false);
        },
        SelectNavPage: {
          setActive: () => {
            const { selectedFilter } = Current.Nav;
            for (const s of selectMarketQuote) {
              const buttons = s.children;
              for (const b of buttons) {
                if (b.dataset.nav == selectedFilter) {
                  b.setAttribute("class", "btn btn-outline-secondary active");
                } else {
                  b.setAttribute("class", "btn btn-outline-secondary");
                }
              }
            }
          },
          whenClicked: (event) => {
            const clicked = event.target.dataset.nav;
            Current.Nav.selectedFilter = clicked;
            Markets.Nav.User.SelectNavPage.setActive();
            let search = "";
            for (const s of searchMarketsInput) {
              if (s.value) {
                search = s.value;
              }
            }
            Markets.Load.withStored(search.length ? true : false);
          },
        },
      },
      Filter: {
        navList: (withSearchWord = false) => {
          const { allSymbols } = Markets;
          const { Favorites } = Current;
          const { selectedFilter, searchWord } = Current.Nav;
          const all = allSymbols.map((a) => {
            return a.list;
          });
          Current.Nav.filteredSymbols = all
            .filter((f) => {
              if (selectedFilter == "All") {
                if (withSearchWord) {
                  return f.base.includes(searchWord);
                }
                return f;
              } else if (selectedFilter == "Fav") {
                const [isFav] = Favorites.filter((fav) => {
                  return fav.S == f.symbol;
                });
                if (withSearchWord) {
                  return isFav && f.base.includes(searchWord);
                }
                return isFav;
              } else {
                if (withSearchWord) {
                  return (
                    f.quote == selectedFilter && f.base.includes(searchWord)
                  );
                }
                return f.quote == selectedFilter;
              }
            })
            .reduce((t, el) => {
              const { base, quote, symbol, name, price, change } = el;
              const [isFav] = Favorites.filter((fav) => {
                return fav.S == symbol;
              });
              let fav;
              if (isFav) {
                fav = true;
              } else {
                fav = false;
              }
              t[symbol] = {
                symbol,
                base,
                quote,
                name,
                price,
                change,
                isFav: fav,
              };

              return t;
            }, {});
        },
      },
      Sort: {
        whenClicked: (event) => {
          const { by, isAsc } = Current.Nav.sort;
          const clicked = event.target.dataset.sort;
          Current.Nav.sort.by = clicked;
          let direction = isAsc;
          if (by == clicked) {
            direction = isAsc ? false : true;
            Current.Nav.sort.isAsc = direction;
          }
          const svg = {
            true: `
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="16"
                height="16"
                fill="currentColor"
                class="bi bi-arrow-up"
                viewBox="0 0 16 16"
                data-sort="${clicked}"
              >
                <path
                  fill-rule="evenodd"
                  d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"
                />
              </svg>
            `,
            false: `
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="16"
                height="16"
                fill="currentColor"
                class="bi bi-arrow-down"
                viewBox="0 0 16 16"
              >
                <path
                  fill-rule="evenodd"
                  d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"
                />
              </svg>
            `,
          };
          document.getElementById("marketNavSvg").remove();
          const span = document.createElement("span");
          span.setAttribute("id", "marketNavSvg");
          span.setAttribute("data-sort", clicked);
          span.innerHTML = svg[direction];
          document.getElementById(`sortBy${clicked}`).append(span);
          Markets.Load.withStored();
        },
        notClicked: () => {
          const { filteredSymbols } = Current.Nav;
          const { by, isAsc } = Current.Nav.sort;
          const arr = Object.keys(filteredSymbols).map((key) => {
            return filteredSymbols[key];
          });
          Current.Nav.sortedSymbols = Utility.Data.sorts(arr, by, isAsc);
        },
      },
    },
    Load: {
      withRequest: () => {
        Utility.Page.loading("marketsListSm", true);
        Utility.Page.loading("marketsListLg", true);
        Utility.Server.run()
          .withSuccessHandler((result) => {
            Utility.Page.loading("marketsListSm", false);
            Utility.Page.loading("marketsListLg", false);
            Markets.allSymbols = result;
            Markets.Load.withStored();
            Terminal.init();
          })
          .withFailureHandler((err) => {
            Utility.Page.loading("marketsListSm", false);
            Utility.Page.loading("marketsListLg", false);
            TradeUtility.Page.errResponses(err);
          })
          .loadAllMarkets();
      },
      withStored: (usingSearch = false) => {
        Markets.Nav.Filter.navList(usingSearch);
        Markets.Nav.Sort.notClicked();
        Markets.Populate.htmlList();
      },
      savedFavorites: () => {
        Utility.Server.run()
          .withSuccessHandler((result) => {
            Current.Favorites = result;
          })
          .withFailureHandler((err) => {
            TradeUtility.Page.errResponses(err);
          })
          .loadFavLinks();
      },
    },
    Populate: {
      htmlList: () => {
        const { sortedSymbols } = Current.Nav;
        for (const m of marketsList) {
          m.innerHTML = "";
          const mListId = m.id;
          const htmlString = sortedSymbols.reduce((t, el) => {
            const { base, quote, symbol, name, price, change, isFav } = el;
            let delimColor;
            if (change > 0) {
              delimColor = "success";
            } else if (change < 0) {
              delimColor = "danger";
            } else {
              delimColor = "light";
            }
            let fmtPrice;
            if (quote == "BTC") {
              fmtPrice = "₿" + price;
            } else if (quote == "USDT") {
              fmtPrice = "₮" + price;
            } else {
              fmtPrice = "Ξ" + price;
            }
            let favButton;
            if (isFav) {
              favButton = `<button type="button" data-symbol="${symbol}" class="btn btn-sm btn-outline-danger px-0 no-focus removeFav">~</button>`;
            } else {
              favButton = `<button type="button" data-symbol="${symbol}" class="btn btn-sm btn-outline-primary px-0 no-focus addFav">+</button>`;
            }
            const chooseId =
              mListId == "marketsListSm"
                ? `choose_sm_${symbol}`
                : `choose_lg_${symbol}`;
            const active = Current.Symbol.is == symbol ? "active" : null;
            const htmlTemplate = `
            <div id="${chooseId}" class="list-group-item py-0 ${active}">
              <div class="row">
                <div class="col-11 px-0 text-start">
                  <div
                  type="button"
                  class="chooseSymbol ps-1 py-0 text-white"
                  aria-current="false"
                  data-symbol="${symbol}"
                  data-base="${base}"
                  data-quote="${quote}"
                  data-name="${name}"
                  ${
                    mListId == "marketsListSm"
                      ? `data-bs-dismiss="offcanvas"`
                      : ""
                  }
                  >
                    <div class="row clickFix">
                      <div class="col">
                        <div class="row">
                          <div class="col-auto text-start">
                            <div>
                              <span>${base}</span>
                              <span class="badge bg-secondary">${quote}</span>
                            </div>
                          </div>
                          <div class="col text-end">
                            <div class="text-${delimColor}">${change}%</div>
                          </div>
                        </div>
                      </div>
                    </div>
                    <div class="row clickFix">
                      <div class="col">
                        <div class="row">
                          <div class="col-6 text-start">
                            <div class="text-secondary text-truncate">${name}</div>
                          </div>
                          <div class="col-6 text-end">
                            <div class="text-secondary text-truncate">${fmtPrice}</div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="col-1 px-1 align-self-center text-end">
                  ${favButton}
                </div>
              </div>
            </div>
                `;
            return (t += htmlTemplate);
          }, "");
          m.innerHTML = htmlString;
        }

        //Markets.Populate.navListHtmlElementIDs();
      },
      navListHtmlElementIDs: () => {
        const { filteredSymbols } = Current.Nav;
        for (const key in filteredSymbols) {
          if (Object.hasOwnProperty.call(filteredSymbols, key)) {
            const symbol = filteredSymbols[key];
            symbol.html.getElById = document.getElementById(symbol.html.id);
          }
        }
      },
    },
  };

  // Stats ===========================
  // cStats
  const statsOpen = document.getElementById("statsOpen");
  const statsHigh = document.getElementById("statsHigh");
  const statsLow = document.getElementById("statsLow");
  const statsLast = document.getElementById("statsLast");
  const statsBVol = document.getElementById("statsBVol");
  const statsQVol = document.getElementById("statsQVol");
  const Stats = {
    WS: {
      update: (msg) => {
        Stats.wsHtml(msg[0]);
      },
    },
    init: () => {
      Current.Symbol.stats.price = 0;
      Stats.loading(true);
      Stats.wsLoading(true);
      Stats.request();
    },
    request: () => {
      const { is } = Current.Symbol;
      Utility.Server.run()
        .withSuccessHandler((stats) => {
          Stats.loading(false);
          Stats.html(stats);
        })
        .withFailureHandler((err) => {
          Stats.loading(false);
          TradeUtility.Page.errResponses(err);
        })
        .load24hStats(is);
    },
    wsLoading: (isLoading) => {
      const elements = [statsOpen, statsHigh, statsLow, statsLast, statsQVol];
      const placeholder = isLoading ? "placeholder col" : "";
      elements.forEach((el) => {
        el.setAttribute("class", placeholder);
      });
    },
    loading: (isLoading) => {
      const elements = [statsBVol];
      const placeholder = isLoading ? "placeholder col" : "";
      elements.forEach((el) => {
        el.setAttribute("class", placeholder);
      });
    },
    wsHtml: (msg) => {
      const { setLength } = Terminal.Form.Util;
      const { stats } = Current.Symbol;
      const { price } = stats;
      const color =
        Number(msg.last_price) > price ? "text-success" : "text-danger";
      const mapped = [
        { id: statsOpen, text: msg.open_24h, color: false },
        { id: statsHigh, text: msg.high_24h, color: false },
        { id: statsLow, text: msg.low_24h, color: false },
        { id: statsLast, text: msg.last_price, color },
        { id: statsQVol, text: msg.base_volume_24h, color: false },
      ];
      mapped.forEach((el) => {
        el.id.innerText = el.text;
        if (el.color) {
          el.id.setAttribute("class", el.color);
        }
      });
      stats.price = Number(msg.last_price);
    },
    html: (stats) => {
      const { setLength } = Terminal.Form.Util;
      const { BVol } = stats;
      const mapped = [{ id: statsBVol, text: BVol, color: false }];
      mapped.forEach((el) => {
        el.id.innerText = Number(el.text).toFixed(2);
        if (el.color) {
          el.id.setAttribute("class", el.color);
        }
      });
    },
  };

  // Chart ===========================
  // cChart
  const chartTerminalContainer = document.getElementById(
    "chartTerminalContainer"
  );
  const chartArea = document.getElementById("chartArea");
  const TradingviewChart = {
    init: () => {
      TradingviewChart.Data.fetchKline();
    },
    WS: {
      update: (msg) => {
        const { candle } = msg[0];
        const { forUpdateTime, toLocalTime } = TradeUtility.Page;
        const time = toLocalTime(candle[0], true);
        const open = Number(candle[1]);
        const high = Number(candle[2]);
        const low = Number(candle[3]);
        const close = Number(candle[4]);
        const volume = Number(candle[5]);
        const currentBar = { time, open, high, low, close };
        const series = TradingviewChart.Html.Chart.seriesObject;
        if (series) {
          series.update(currentBar);
        }
      },
    },
    Data: {
      fetchKline: (from) => {
        const { is, step } = Current.Symbol;
        const { sets } = Current.Chart.Candles;
        Utility.Page.loading("chartArea", true);
        Utility.Server.run()
          .withSuccessHandler((result) => {
            Utility.Page.loading("chartArea", false);
            if (!Array.isArray(result)) {
              console.log("No Data", result);
              chartArea.innerText = "No Data";
              return;
            }
            const convertToLocalTime = result.map((l) => {
              l.time = TradeUtility.Page.toLocalTime(l.time);
              return l;
            });
            Current.Chart.Candles.kline = convertToLocalTime;
            TradingviewChart.Html.Chart.create();
          })
          .withFailureHandler((err) => {
            Utility.Page.loading("chartArea", false);
            TradeUtility.Page.errResponses(err);
          })
          .fetchSymbolKlines(is, step, from, sets);
      },
      updateStep: (event) => {
        const tf = Number(event.target.value);
        const { step } = Current.Symbol;
        if (tf == step) {
          return;
        }
        Current.Symbol.step = tf;
        TradingviewChart.Data.fetchKline();
      },
      updateSets: (event) => {
        const set = Number(event.target.value);
        const { sets } = Current.Chart.Candles;
        if (set == sets) {
          return;
        }
        Current.Chart.Candles.sets = set;
        TradingviewChart.Data.fetchKline();
      },
    },
    Html: {
      Chart: {
        seriesObject: null,
        create: () => {
          const { kline } = Current.Chart.Candles;
          chartArea.innerHTML = "";
          const legend = document.createElement("div");
          legend.setAttribute("class", "legend position-absolute");
          legend.style.zIndex = 2;
          chartArea.appendChild(legend);
          const firstRow = document.createElement("div");
          firstRow.setAttribute("id", "chartSymbol");
          firstRow.innerText = `${Current.Symbol.is} ${Current.Symbol.step}`;
          firstRow.setAttribute("class", "text-light");
          legend.appendChild(firstRow);
          const chart = LightweightCharts.createChart(chartArea, {
            layout: {
              backgroundColor: "#212529",
              textColor: "#ffffff",
            },
            rightPriceScale: {},
            grid: {
              horzLines: {
                color: "#000",
              },
              vertLines: {
                color: "#000",
              },
            },
            crosshair: {
              vertLine: {
                visible: true,
              },
              horzLine: {
                visible: true,
              },
              mode: 0,
            },
            timeScale: {
              timeVisible: true,
              secondsVisible: true,
            },
          });
          const { Validation } = Current.Terminal;
          const minMove = Validation.precision;
          const precision = Validation.priceMaxPrecision;
          const priceFmt = {
            priceFormat: {
              type: "custom",
              formatter: (price) => {
                return price.toFixed(precision);
              },
              precision,
              minMove,
            },
          };
          const candlestickSeries = chart.addCandlestickSeries(priceFmt);
          candlestickSeries.setData(kline);
          TradingviewChart.Html.Chart.seriesObject = candlestickSeries;
          chart.timeScale().fitContent();
          TradingviewChart.Html.Lines.Active.create();
          TradingviewChart.Html.Lines.Breakeven.create();
          TradingviewChart.Html.Markers.create();
          TradeWebSocket.init();
          Orders.init();
        },
      },
      Markers: {
        current: [],
        newMarker: (details) => {
          const { showPrices } = Current.Chart.Markers;
          const shape = details.side == "buy" ? "arrowUp" : "arrowDown";
          const color = details.side == "buy" ? "#23d886" : "#ffc107";
          const price = Terminal.Form.Util.convertToUs(
            Number(details.price_avg)
          );
          const time = TradeUtility.Page.markerTime(details.create_time);
          return {
            time,
            position: "price",
            shape,
            color,
            text: showPrices ? price : " ",
            price,
            size: 0.5,
          };
        },
        toggle: (event) => {
          const { id } = event.target;
          const { Markers } = TradingviewChart.Html;
          const series = TradingviewChart.Html.Chart.seriesObject;
          switch (id) {
            case "toggleMarkers":
              const showState = Current.Chart.Markers.show;
              Current.Chart.Markers.show = showState ? false : true;
              break;
            case "toggleMarkerPrices":
              const priceState = Current.Chart.Markers.showPrices;
              Current.Chart.Markers.showPrices = priceState ? false : true;
              break;

            default:
              break;
          }
          Markers.create();
        },
        create: () => {
          const series = TradingviewChart.Html.Chart.seriesObject;
          const { Markers } = TradingviewChart.Html;
          const { newMarker } = Markers;
          const { closed } = Current.Orders;
          const { kline } = Current.Chart.Candles;
          const oldest = kline[0].time * 1000;
          const markers = closed
            .filter((f) => {
              return new Date(f.create_time).getTime() >= oldest;
            })
            .map((c) => {
              return newMarker(c);
            });

          if (series) {
            const { show } = Current.Chart.Markers;
            if (show) {
              series.setMarkers(markers);
            } else {
              series.setMarkers([]);
            }
          }
        },
      },
      Lines: {
        newLine: (details) => {
          const { category } = Current.Terminal;
          const { base } = Current.Symbol;
          const sideType =
            category == "simple"
              ? selectSimpleSide.value
              : selectSmartSide.value;
          let side;
          if (details.whichOrder == "base") {
            side = sideType;
          } else {
            side = sideType == "buy" ? "sell" : "buy";
          }
          const line = {
            tradeCategory: category,
            lineType: "input",
            side,
            base,
            isFinished: details.isFinished,
          };
          Object.assign(line, details);
          return line;
        },
        Input: {
          newLines: [],
          current: [],
          changeSide: () => {
            const { category } = Current.Terminal;
            const side =
              category == "simple"
                ? selectSimpleSide.value
                : selectSmartSide.value;
            const prevSide = side == "buy" ? "sell" : "buy";
            const { Input } = TradingviewChart.Html.Lines;
            TradingviewChart.Html.Lines.Input.newLines = Input.newLines
              .filter((f) => {
                return f.side == prevSide;
              })
              .map((s) => {
                s.side = side;
                return s;
              });
            TradingviewChart.Html.Lines.Input.create();
          },
          create: () => {
            const { series, styles } = TradingviewChart.Html.Lines.details();
            const { current, newLines } = TradingviewChart.Html.Lines.Input;
            current.forEach((line) => {
              series.removePriceLine(line);
            });
            TradingviewChart.Html.Lines.Input.current = newLines.map((l) => {
              const {
                id,
                price,
                tradeCategory,
                tradeType,
                lineType,
                where,
                side,
                base,
                amt,
                whichOrder,
              } = l;
              const lineInfo = {
                price,
                color:
                  styles[tradeCategory][tradeType][lineType][whichOrder].color[
                    side
                  ],
                lineWidth:
                  styles[tradeCategory][tradeType][lineType][whichOrder].width,
                lineStyle:
                  styles[tradeCategory][tradeType][lineType][whichOrder].style,
                axisLabelVisible: true,
                title:
                  whichOrder == "base"
                    ? `${side} ${amt} ${base} @`
                    : `TP ${side} ${amt} ${base} @`,
              };

              return series.createPriceLine(lineInfo);
            });
          },
        },
        Active: {
          newLines: [],
          current: [],
          toggle: (event) => {
            const { id } = event.target;
            const { Lines, Markers } = Current.Chart;
            const { showActive, showSymbol, showSize, screenshotMode, showTp } =
              Lines;
            const toggleLines = showActive ? false : true;
            const toggleSymbol = showSymbol ? false : true;
            const toggleSize = showSize ? false : true;
            const toggleScreenshotMode = screenshotMode ? false : true;
            const toggleShowTp = showTp ? false : true;
            switch (id) {
              case "toggleActive":
                Lines.showActive = toggleLines;
                break;
              case "toggleLineSymbol":
                Lines.showSymbol = toggleSymbol;
                break;
              case "toggleLineSize":
                Lines.showSize = toggleSize;
                break;
              case "toggleShowTp":
                Lines.showTp = toggleShowTp;
                break;
              case "toggleScreenshotMode":
                if (toggleScreenshotMode) {
                  Lines.showSize = false;
                  Lines.showSymbol = false;
                  Markers.showPrices = false;
                  document.getElementById("chartSymbol").innerText = "***";
                } else {
                  Lines.showSize = true;
                  Lines.showSymbol = true;
                  Markers.showPrices = true;
                  document.getElementById(
                    "chartSymbol"
                  ).innerText = `${Current.Symbol.is} ${Current.Symbol.step}`;
                }
                Lines.screenshotMode = toggleScreenshotMode;
                TradingviewChart.Html.Markers.create();
                break;

              default:
                break;
            }
            TradingviewChart.Html.Lines.Active.create();
          },
          create: () => {
            const { showActive, showSize, showSymbol, showTp } =
              Current.Chart.Lines;
            const { series, styles } = TradingviewChart.Html.Lines.details();
            const { current, newLines } = TradingviewChart.Html.Lines.Active;
            if (showActive) {
              current.forEach((line) => {
                series.removePriceLine(line);
              });
              let linesToCreate;
              if (showTp) {
                linesToCreate = newLines;
              } else {
                linesToCreate = newLines.filter((l) => {
                  return l.whichOrder == "base";
                });
              }
              TradingviewChart.Html.Lines.Active.current = linesToCreate.map(
                (l) => {
                  const {
                    id,
                    price,
                    tradeCategory,
                    tradeType,
                    lineType,
                    where,
                    side,
                    base,
                    amt,
                    whichOrder,
                  } = l;
                  let title = `${side}`;
                  if (!showSize) {
                    title += ` ***`;
                  } else {
                    title += ` ${amt}`;
                  }
                  if (!showSymbol) {
                    title += ` *** @`;
                  } else {
                    title += ` ${base} @`;
                  }
                  const lineInfo = {
                    price,
                    color:
                      styles[tradeCategory][tradeType][lineType][whichOrder]
                        .color[side],
                    lineWidth:
                      styles[tradeCategory][tradeType][lineType][whichOrder]
                        .width,
                    lineStyle:
                      styles[tradeCategory][tradeType][lineType][whichOrder]
                        .style,
                    axisLabelVisible: true,
                    title,
                  };
                  return series.createPriceLine(lineInfo);
                }
              );
            } else {
              current.forEach((line) => {
                series.removePriceLine(line);
              });
            }
          },
          highlight: (orderId) => {
            const { series, styles } = TradingviewChart.Html.Lines.details();
            const { current, newLines } = TradingviewChart.Html.Lines.Active;
            current.forEach((line) => {
              series.removePriceLine(line);
            });
            TradingviewChart.Html.Lines.Active.current = newLines
              .filter((f) => {
                return f.id == orderId;
              })
              .map((l) => {
                const {
                  id,
                  price,
                  tradeCategory,
                  tradeType,
                  lineType,
                  where,
                  side,
                  base,
                  amt,
                  whichOrder,
                  isFinished,
                } = l;
                let title;
                title = `${side} ${amt} ${base} @`;
                const lineInfo = {
                  price,
                  color: styles.highlight[whichOrder].color[side],
                  lineWidth: styles.highlight[whichOrder].width,
                  lineStyle: styles.highlight[whichOrder].style,
                  axisLabelVisible: true,
                  title,
                };

                return series.createPriceLine(lineInfo);
              });
          },
        },
        Breakeven: {
          newLines: [],
          current: [],
          create: () => {
            const { series, styles } = TradingviewChart.Html.Lines.details();
            const { current, newLines } = TradingviewChart.Html.Lines.Breakeven;
            current.forEach((line) => {
              series.removePriceLine(line);
            });
            TradingviewChart.Html.Lines.Breakeven.current = newLines.map(
              (l) => {
                const { price, lineType } = l;
                const lineInfo = {
                  price,
                  color: styles[lineType].color,
                  lineWidth: styles[lineType].width,
                  lineStyle: styles[lineType].style,
                  axisLabelVisible: true,
                  title: `BE: @`,
                };
                return series.createPriceLine(lineInfo);
              }
            );
          },
        },
        details: () => {
          return {
            series: TradingviewChart.Html.Chart.seriesObject,
            styles: {
              simple: {
                single: {
                  input: {
                    base: {
                      width: 1,
                      style: LightweightCharts.LineStyle.Solid,
                      color: {
                        buy: "#23d886",
                        sell: "#be1238",
                      },
                    },
                    tp: {
                      width: 1,
                      style: LightweightCharts.LineStyle.Dotted,
                      color: {
                        buy: "#667174",
                        sell: "#667174",
                      },
                    },
                  },
                  active: {
                    base: {
                      width: 1,
                      style: LightweightCharts.LineStyle.Dashed,
                      color: {
                        buy: "#198754",
                        sell: "#dc3545",
                      },
                    },
                    tp: {
                      width: 1,
                      style: LightweightCharts.LineStyle.Dotted,
                      color: {
                        buy: "#667174",
                        sell: "#667174",
                      },
                    },
                  },
                },
                ladder: {
                  width: 1,
                  innerPrice: {
                    base: {
                      style: LightweightCharts.LineStyle.Dashed,
                      color: {
                        buy: "#23d886",
                        sell: "#be1238",
                      },
                    },
                  },
                  outerPrice: {
                    base: {
                      style: LightweightCharts.LineStyle.Solid,
                      color: {
                        buy: "#23d886",
                        sell: "#be1238",
                      },
                    },
                  },
                  isError: {
                    base: {
                      style: LightweightCharts.LineStyle.Dotted,
                      color: {
                        buy: "#fd7e14",
                        sell: "#fd7e14",
                      },
                    },
                  },
                },
              },
              smart: {
                single: {
                  input: {
                    base: {
                      width: 1,
                      style: LightweightCharts.LineStyle.Solid,
                      color: {
                        buy: "#23d886",
                        sell: "#be1238",
                        tp: "#667174",
                      },
                    },
                    tp: {
                      width: 1,
                      style: LightweightCharts.LineStyle.Dotted,
                      color: {
                        buy: "#667174",
                        sell: "#667174",
                      },
                    },
                  },
                  active: {
                    base: {
                      width: 1,
                      style: LightweightCharts.LineStyle.Dashed,
                      color: {
                        buy: "#198754",
                        sell: "#dc3545",
                        tp: "#667174",
                      },
                    },
                    tp: {
                      width: 1,
                      style: LightweightCharts.LineStyle.Dotted,
                      color: {
                        buy: "#667174",
                        sell: "#667174",
                      },
                    },
                  },
                },
                ladder: {
                  width: 1,
                  innerPrice: {
                    base: {
                      style: LightweightCharts.LineStyle.Dashed,
                      color: {
                        buy: "#23d886",
                        sell: "#be1238",
                      },
                    },
                  },
                  outerPrice: {
                    base: {
                      style: LightweightCharts.LineStyle.Solid,
                      color: {
                        buy: "#23d886",
                        sell: "#be1238",
                      },
                    },
                  },
                  isError: {
                    base: {
                      style: LightweightCharts.LineStyle.Dotted,
                      color: {
                        buy: "#fd7e14",
                        sell: "#fd7e14",
                      },
                    },
                  },
                  smartTp: {
                    tp: {
                      style: LightweightCharts.LineStyle.Dotted,
                      color: {
                        buy: "#667174",
                        sell: "#667174",
                      },
                    },
                  },
                },
              },
              breakEven: {
                width: 2,
                style: LightweightCharts.LineStyle.Solid,
                color: "#ffc107",
              },
              highlight: {
                base: {
                  width: 1,
                  style: LightweightCharts.LineStyle.Solid,
                  color: {
                    buy: "#23d886",
                    sell: "#be1238",
                  },
                },
                tp: {
                  width: 1,
                  style: LightweightCharts.LineStyle.Dotted,
                  color: {
                    buy: "#23d886",
                    sell: "#be1238",
                  },
                },
              },
            },
          };
        },
      },
    },
  };

  // User Orders ===========================
  // cOrders
  const ordersLoading = document.getElementById("ordersLoading");
  const noActiveOrdersContainer = document.getElementById(
    "noActiveOrdersContainer"
  );
  const activeOrdersContainer = document.getElementById(
    "activeOrdersContainer"
  );
  const activeOrdersTable = document.getElementById("activeOrdersTable");
  const closedOrdersContainer = document.getElementById(
    "closedOrdersContainer"
  );
  const closedOrdersTable = document.getElementById("closedOrdersTable");
  const noClosedOrdersContainer = document.getElementById(
    "noClosedOrdersContainer"
  );
  const walletsContainer = document.getElementById("walletsContainer");
  const walletsTable = document.getElementById("walletsTable");
  const noWalletsContainer = document.getElementById("noWalletsContainer");
  const ordersTotal = document.getElementById("ordersTotal");
  const breakEvenPrice = document.getElementById("breakEvenPrice");
  const pnl = document.getElementById("pnl");
  const refresh = document.getElementById("refresh");
  const Orders = {
    init: async () => {
      if (Current.Orders.nav == "viewActiveOrders") {
        Orders.Import.viewActiveOrders();
      }
      if (Current.Orders.nav == "viewClosedOrders") {
        Orders.Import.viewClosedOrders();
      } else {
        Orders.Import.viewClosedOrders(false, true);
      }
    },
    counter: null,
    updateInterval: () => {
      Orders.updateCounter();
      Orders.Import.viewActiveOrders(false, true);
      Orders.Import.viewClosedOrders(false, true);
    },
    updateCounter: () => {
      clearInterval(Orders.counter);
      refresh.innerText = 60;
      Orders.counter = setInterval(() => {
        refresh.innerText = Number(refresh.innerText) - 1;
      }, 1000);
    },
    update: (init = true, update = false) => {
      const { nav } = Current.Orders;
      Orders.Import[nav](init, update);
    },
    Nav: {
      changeView: (event) => {
        const viewIds = ["viewActiveOrders", "viewClosedOrders", "viewWallets"];
        const views = {
          viewActiveOrders: activeOrdersContainer,
          viewClosedOrders: closedOrdersContainer,
          viewWallets: walletsContainer,
        };
        let selected;
        viewIds.forEach((v) => {
          const view = document.getElementById(v);
          const text = view.innerText;
          if (text == event.target.innerText) {
            selected = event.target.id;
            view.setAttribute("class", "text-light text-decoration-none");
          } else {
            view.setAttribute("class", "text-secondary text-decoration-none");
            views[v].setAttribute("class", "d-none");
          }
        });
        Current.Orders.nav = selected;
        Orders.update();
      },
    },
    Import: {
      viewActiveOrders: (init = true, update = false) => {
        const { is } = Current.Symbol;
        if (init) {
          ordersTotal.innerText = 0;
          activeOrdersTable.innerHTML = "";
          Utility.Page.loading("ordersLoading", true);
        }
        Utility.Server.run()
          .withSuccessHandler((result) => {
            Current.Orders.open = result;
            if (init) {
              Utility.Page.loading("ordersLoading", false);
              Orders.Html.OpenOrders.hasResults(!result.length ? false : true);
              Orders.Html.OpenOrders.populate();
            }
            if (update) {
              Orders.Html.OpenOrders.populate();
            }
            Orders.Html.OpenOrders.populateLines();
          })
          .withFailureHandler((err) => {
            if (init) {
              Utility.Page.loading("ordersLoading", false);
            }
            TradeUtility.Page.errResponses(err);
          })
          .viewActiveOrders(is);
      },
      viewClosedOrders: (init = true, update = false) => {
        const { is } = Current.Symbol;
        if (init) {
          ordersTotal.innerText = 0;
          closedOrdersTable.innerHTML = "";
          Utility.Page.loading("ordersLoading", true);
        }
        Utility.Server.run()
          .withSuccessHandler((result) => {
            Current.Orders.closed = result;
            if (init) {
              Utility.Page.loading("ordersLoading", false);
              if (!result.length) {
                Orders.Html.ClosedOrders.hasResults(false);
              } else {
                Orders.Html.ClosedOrders.hasResults(true);
                Orders.Html.ClosedOrders.populate();
              }
            }
            if (update) {
              Orders.Html.ClosedOrders.populate();
            }
            Orders.Html.ClosedOrders.populateBreakEven();
            TradingviewChart.Html.Markers.create();
          })
          .withFailureHandler((err) => {
            if (init) {
              Utility.Page.loading("ordersLoading", false);
            }
            TradeUtility.Page.errResponses(err);
          })
          .viewClosedOrders(is);
      },
      viewWallets: () => {
        walletsTable.innerHTML = "";
        ordersTotal.innerText = 0;
        Utility.Page.loading("ordersLoading", true);
        Utility.Server.run()
          .withSuccessHandler((result) => {
            Utility.Page.loading("ordersLoading", false);
            if (!result.length) {
              Orders.Html.Wallets.hasResults(false);
              return;
            }
            Current.Orders.wallets = result;
            Orders.Html.Wallets.hasResults(true);
            Orders.Html.Wallets.populate();
          })
          .withFailureHandler((err) => {
            Utility.Page.loading("ordersLoading", false);
            TradeUtility.Page.errResponses(err);
          })
          .getWallets();
      },
      calculateBreakEven: () => {
        const { is } = Current.Symbol;
        Utility.Server.run()
          .withSuccessHandler((result) => {
            Current.Orders.closed = result;
            Orders.Html.ClosedOrders.populateBreakEven();
          })
          .withFailureHandler((err) => {
            TradeUtility.Page.errResponses(err);
          })
          .viewClosedOrders(is);
      },
    },
    User: {
      OpenOrders: {
        timeout: null,
        prevId: 0,
        hover: (event) => {
          const o = Orders.User.OpenOrders;
          const row = event.target.closest("tr");
          const order_id = row.dataset.orderId;
          const toRow = event.toElement.closest("tr");
          const checkForId = toRow ? "orderId" in toRow.dataset : false;
          switch (event.type) {
            case "mouseout":
              if (order_id !== Orders.User.OpenOrders.prevId || !checkForId) {
                clearTimeout(o.timeout);
                TradingviewChart.Html.Lines.Active.create();
                Orders.User.OpenOrders.prevId = 0;
              }
              break;
            case "mouseover":
              if (order_id !== Orders.User.OpenOrders.prevId && checkForId) {
                Orders.User.OpenOrders.prevId = order_id;
                clearTimeout(o.timeout);
                o.timeout = setTimeout(
                  TradingviewChart.Html.Lines.Active.highlight,
                  100,
                  order_id
                );
              }
              break;

            default:
              break;
          }
        },
        cancel: (event) => {
          if (event.target.type == "button") {
            const { isCanceling } = Current.Orders;
            if (isCanceling) {
              return;
            }
            const { orderId } = event.target.dataset;
            Utility.Page.loading("cancelActions", true, null, "small", true);
            Current.Orders.isCanceling = true;
            Utility.Server.run()
              .withSuccessHandler((result) => {
                Current.Orders.isCanceling = false;
                Utility.Page.loading(
                  "cancelActions",
                  false,
                  null,
                  null,
                  null,
                  "X"
                );
                if (result) {
                  Orders.update();
                  Terminal.Wallet.getAvailable();
                }
              })
              .withFailureHandler((err) => {
                Current.Orders.isCanceling = false;
                Utility.Page.loading(
                  "cancelActions",
                  false,
                  null,
                  null,
                  null,
                  "X"
                );
                TradeUtility.Page.errResponses(err);
              })
              .cancelActiveOrder(orderId);
          }
        },
        cancelAll: async (event) => {
          const { isCanceling } = Current.Orders;
          if (isCanceling) {
            return;
          }
          const { id } = event.target;
          const { is } = Current.Symbol;
          let side;
          switch (id) {
            case "cancelBuyActive":
              side = "buy";
              break;
            case "cancelSellActive":
              side = "sell";
              break;
            case "cancelAllSelected":
              break;
            default:
              break;
          }
          const actions = {
            chunkActiveOrders: async () => {
              return new Promise((resolve, reject) => {
                Utility.Server.run()
                  .withSuccessHandler((result) => {
                    const chunked = Utility.Data.chunk(result, 10, "arr");
                    resolve(chunked);
                  })
                  .withFailureHandler((err) => {
                    reject(err);
                  })
                  .viewActiveOrders(is, side);
              });
            },
            performPartialCheck: async (orderChunk) => {
              return new Promise((resolve, reject) => {
                Utility.Server.run()
                  .withSuccessHandler((result) => {
                    resolve(result);
                  })
                  .withFailureHandler((err) => {
                    reject(err);
                  })
                  .checkCancelIdForPartial(orderChunk);
              });
            },
            cancelOrdersWithSuccessResponse: async (noDetail) => {
              return new Promise((resolve, reject) => {
                Utility.Server.run()
                  .withSuccessHandler((result) => {
                    resolve(result);
                  })
                  .withFailureHandler((err) => {
                    reject(err);
                  })
                  .cancelActiveNoCheck(noDetail);
              });
            },
            cancelAllExchange: async () => {
              return new Promise((resolve, reject) => {
                Utility.Server.run()
                  .withSuccessHandler((result) => {
                    resolve(result);
                  })
                  .withFailureHandler((err) => {
                    reject(err);
                  })
                  .cancelAllExchange(is, side);
              });
            },
            addToDB: async (tradeDetails) => {
              return new Promise((resolve, reject) => {
                Utility.Server.run()
                  .withSuccessHandler((result) => {
                    resolve(result);
                  })
                  .withFailureHandler((err) => {
                    reject(err);
                  })
                  .checkIfPartialExistsOnDB(tradeDetails);
              });
            },
          };
          Utility.Page.loading("cancelActions", true, null, "small", true);
          Current.Orders.isCanceling = true;
          const isSelected = id == "cancelAllSelected";
          let chunked;
          if (isSelected) {
            const selected = document.getElementsByClassName("selectOrder");
            const orderIds = [];
            for (const s of selected) {
              if (s.checked == true) {
                orderIds.push(s.value);
              }
            }
            chunked = Utility.Data.chunk(
              orderIds.map((o) => {
                return { order_id: o.split("-")[0] };
              }),
              10,
              "arr"
            );
          } else {
            try {
              chunked = await actions.chunkActiveOrders();
              if (!chunked.length) {
                const err = Error("No orders to cancel");
                throw err;
              }
            } catch (err) {
              TradeUtility.Page.errResponses(err);
            }
          }

          if (!chunked) {
            Utility.Page.loading("cancelActions", false, null, null, null, "X");
            Current.Orders.isCanceling = false;
            return;
          }
          let chunkIndex = 0;
          const cancelDetails = {
            tradeDetails: [],
            noDetail: [],
            toCancel: [],
          };
          const exceededPartialCheckWrapper = async (
            chunks,
            lastTriedIndex = false
          ) => {
            try {
              let loopIndex = 0;
              for await (const chunkOfOrders of chunks) {
                let result;
                if (lastTriedIndex >= 0) {
                  if (loopIndex >= lastTriedIndex) {
                    chunkIndex = loopIndex;
                    result = await actions.performPartialCheck(chunkOfOrders);
                  }
                } else {
                  chunkIndex = loopIndex;
                  result = await actions.performPartialCheck(chunkOfOrders);
                }
                cancelDetails.tradeDetails = [
                  ...cancelDetails.tradeDetails,
                  ...result.tradeDetails,
                ];
                cancelDetails.noDetail = [
                  ...cancelDetails.noDetail,
                  ...result.noDetail,
                ];
                cancelDetails.toCancel = [
                  ...cancelDetails.toCancel,
                  ...result.toCancel,
                ];
                loopIndex += 1;
              }
            } catch (err) {
              if (err == "Exceeded maximum execution time") {
                exceededPartialCheckWrapper(chunks, chunkIndex);
              } else {
                Utility.Page.loading(
                  "cancelActions",
                  false,
                  null,
                  null,
                  null,
                  "X"
                );
                Current.Orders.isCanceling = false;
                throw err;
              }
            }
          };

          try {
            await exceededPartialCheckWrapper(chunked);
            if (!cancelDetails.toCancel.length) {
              Utility.Page.loading(
                "cancelActions",
                false,
                null,
                null,
                null,
                "X"
              );
              Current.Orders.isCanceling = false;
              const err = Error("No orders to cancel");
              TradeUtility.Page.errResponses(err);
              return;
            }
          } catch (err) {
            TradeUtility.Page.errResponses(err);
          }
          let cont = false;
          if (cancelDetails.tradeDetails.length) {
            try {
              await actions.addToDB(cancelDetails.tradeDetails);
              cont = true;
            } catch (err) {
              Current.Orders.isCanceling = false;
              TradeUtility.Page.errResponses(err);
            }
          } else {
            cont = true;
          }
          const hasNoDetail = cancelDetails.noDetail.length && cont;
          if (!isSelected && !hasNoDetail) {
            try {
              await actions.cancelAllExchange(is, side);
            } catch (err) {
              Current.Orders.isCanceling = false;
              TradeUtility.Page.errResponses(err);
            }
          }
          if (hasNoDetail || isSelected) {
            try {
              await actions.cancelOrdersWithSuccessResponse(
                cancelDetails.toCancel
              );
            } catch (err) {
              TradeUtility.Page.errResponses(err);
            }
          }
          Terminal.Wallet.getAvailable();
          Orders.update();
          Utility.Page.loading("cancelActions", false, null, null, null, "X");
          Current.Orders.isCanceling = false;
        },
      },
    },
    Html: {
      OpenOrders: {
        hasResults: (hasResults) => {
          noWalletsContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          noActiveOrdersContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          noClosedOrdersContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          if (!hasResults) {
            noActiveOrdersContainer.setAttribute(
              "class",
              "d-block text-secondary mt-5"
            );
            activeOrdersContainer.setAttribute("class", "d-none");
            activeOrdersTable.innerHTML = "";
            return;
          }
          activeOrdersContainer.setAttribute("class", "d-block");
        },
        populate: () => {
          const { open } = Current.Orders;
          const { nav } = Current.Orders;
          if (nav == "viewActiveOrders") {
            ordersTotal.innerText = open.length;
          }
          const tableRows = open.reduce((t, order) => {
            const {
              order_id,
              error_detail,
              is_pending,
              symbol,
              create_time,
              side,
              type,
              price,
              price_avg,
              size,
              notional,
              filled_notional,
              filled_size,
              unfilled_volume,
              status,
              is_smart,
              source_id,
              tp_price,
            } = order;

            const priceFmt = Terminal.Form.Util.convertToUs(
              Number(price_avg) > 0 ? Number(price_avg) : Number(price)
            );
            const tpPriceFmt = Terminal.Form.Util.convertToUs(tp_price);
            const color = side == "buy" ? "text-success" : "text-danger";
            let tableRow;
            tableRow = `
            <tr data-order-id="${order_id}">
              <td scope="row" class="text-center">
                <div class="form-check form-check-inline m-0">
                  <input
                    class="form-check-input selectOrder"
                    type="checkbox"
                    value="${order_id}-${symbol}"
                  />
                </div>
              </td>
              <td class="col">
                <span class="d-inline-block text-truncate-left" data-bs-toggle="tooltip" data-bs-placement="top" title="${create_time}">
                  ${create_time}
                </span>
              </td>
              <td class="col">${symbol}</td>
              <td class="${color}">${side}</td>
              <td class="col">
                <span class="d-inline-block text-truncate-left" data-bs-toggle="tooltip" data-bs-placement="top" title="${priceFmt}">
                  ${priceFmt}
                </span>
              </td>
              <td class="col">
                <span class="d-inline-block text-truncate-left" data-bs-toggle="tooltip" data-bs-placement="top" title="${filled_size} : ${size} Filled">
                  ${filled_size}/${size}
                </span>
              </td>
              <td class="col">${notional}</td>
              <td class="col">${is_smart}</td>
              <td class="col">${source_id ? "TP" : "BP"}</td>
              <td class="col">
                <span class="d-inline-block text-truncate-left" data-bs-toggle="tooltip" data-bs-placement="top" title="${
                  source_id ? "BP: " : "TP: "
                }${tp_price ? tpPriceFmt : "N/A"}">
                  ${source_id ? "BP: " : "TP: "}${tp_price ? tpPriceFmt : "N/A"}
                </span>
              </td>
              <td class="col">
                <button type="button" class="btn btn-sm btn-danger py-0 no-focus" data-order-id="${order_id}">X</button>
              </td>
            </tr>`;
            return (t += tableRow);
          }, "");
          activeOrdersTable.innerHTML = tableRows;
          const tooltipTriggerList = [].slice.call(
            activeOrdersTable.querySelectorAll('[data-bs-toggle="tooltip"]')
          );
          const tooltipList = tooltipTriggerList.map(function (
            tooltipTriggerEl
          ) {
            return new bootstrap.Tooltip(tooltipTriggerEl, {
              trigger: "hover",
            });
          });
        },
        populateLines: () => {
          const { category } = Current.Terminal;
          const { base } = Current.Symbol;
          const { open } = Current.Orders;
          const baseLines = open.map((o) => {
            const {
              order_id,
              error_detail,
              is_pending,
              symbol,
              create_time,
              side,
              type,
              price,
              price_avg,
              size,
              notional,
              filled_notional,
              filled_size,
              unfilled_volume,
              status,
              is_smart,
              source_id,
              tp_price,
            } = o;
            return {
              id: order_id,
              price: Number(price_avg) > 0 ? Number(price_avg) : Number(price),
              tradeCategory: category,
              tradeType: "single",
              lineType: "active",
              where: "openOrders",
              side: side,
              base,
              amt: `${filled_size}/${size}`,
              whichOrder: "base",
              isFinished: source_id ? true : false,
            };
          });
          const tpLines = open
            .filter((f) => {
              return f.is_smart == "true";
            })
            .map((o) => {
              const { order_id, side, tp_price, size } = o;
              return {
                id: order_id,
                price: Number(tp_price),
                tradeCategory: category,
                tradeType: "single",
                lineType: "active",
                where: "openOrders",
                side: side == "buy" ? "sell" : "buy",
                base,
                amt: size,
                whichOrder: "tp",
              };
            });
          TradingviewChart.Html.Lines.Active.newLines = [
            ...baseLines,
            ...tpLines,
          ];
          if (TradingviewChart.Html.Chart.seriesObject) {
            TradingviewChart.Html.Lines.Active.create();
          }
        },
      },
      ClosedOrders: {
        hasResults: (hasResults) => {
          noWalletsContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          noActiveOrdersContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          noClosedOrdersContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          if (!hasResults) {
            noClosedOrdersContainer.setAttribute(
              "class",
              "d-block text-secondary mt-5"
            );
            closedOrdersContainer.setAttribute("class", "d-none");
            closedOrdersTable.innerHTML = "";
            return;
          }

          closedOrdersContainer.setAttribute("class", "d-block");
        },
        populate: () => {
          const { closed } = Current.Orders;
          const { nav } = Current.Orders;
          if (nav == "viewClosedOrders") {
            ordersTotal.innerText = closed.length;
          }
          const tableRows = closed.reduce((t, order) => {
            const {
              detail_id,
              order_id,
              symbol,
              create_time,
              side,
              price_avg,
              notional,
              size,
              fees,
              fee_coin_name,
              exec_type,
            } = order;
            const priceFmt = Terminal.Form.Util.convertToUs(Number(price_avg));
            const color = side == "buy" ? "text-success" : "text-danger";
            const tableRow = `
            <tr>
              <td scope="row">${create_time}</th>
              <td>${symbol}</td>
              <td class="${color}">${side}</td>
              <td>${priceFmt}</td>
              <td>${size}</td>
              <td>${notional}</td>
            </tr>`;

            return (t += tableRow);
          }, "");
          closedOrdersTable.innerHTML = tableRows;
        },
        populateBreakEven: () => {
          breakEvenPrice.innerText = 0;
          const { setLength } = Terminal.Form.Util;
          const { closed } = Current.Orders;
          const calc = {
            returnBuys: (o) => {
              return o.side == "buy";
            },
            returnSells: (o) => {
              return o.side == "sell";
            },
            sumBase: (t, o) => {
              const { size } = o;
              return (t += Number(size));
            },
            sumQuote: (t, o) => {
              const { notional } = o;
              return (t += Number(notional));
            },
            sumFees: (t, o) => {
              const { fees } = o;
              return (t += Number(fees));
            },
          };
          const totalBoughtBase = closed
            .filter(calc.returnBuys)
            .reduce(calc.sumBase, 0);
          const totalSoldBase = closed
            .filter(calc.returnSells)
            .reduce(calc.sumBase, 0);
          const totalBoughtQuote = closed
            .filter(calc.returnBuys)
            .reduce(calc.sumQuote, 0);
          const totalSoldQuote = closed
            .filter(calc.returnSells)
            .reduce(calc.sumQuote, 0);
          const totalBoughtFees = closed
            .filter(calc.returnBuys)
            .reduce(calc.sumFees, 0);
          const totalSoldFees = closed
            .filter(calc.returnSells)
            .reduce(calc.sumFees, 0);

          const totalBase = totalBoughtBase - totalSoldBase;
          const totalQuote =
            totalBoughtQuote + totalBoughtFees + totalSoldFees - totalSoldQuote;
          let BE = totalQuote / totalBase;
          if (BE > 999999 || BE < 0) {
            BE = 0;
          }
          const price = totalQuote < 0 ? 0 : setLength(BE, "price");
          const profit =
            totalSoldQuote -
            (totalBoughtQuote + totalBoughtFees + totalSoldFees);
          const line = [
            {
              id: 0,
              price: Number(price),
              lineType: "breakEven",
              where: "breakEven",
            },
          ];
          const color =
            profit == 0
              ? "text-muted"
              : profit > 0
              ? "text-success"
              : "text-danger";
          pnl.setAttribute("class", color);
          if (!closed.length) {
            breakEvenPrice.innerText = 0;
            pnl.innerText = 0;
            TradingviewChart.Html.Lines.Breakeven.newLines = [];
          } else {
            breakEvenPrice.innerText = price;
            pnl.innerText = profit.toFixed(4);
            switch (price) {
              case 0:
                TradingviewChart.Html.Lines.Breakeven.newLines = [];
                break;
              case Infinity:
                TradingviewChart.Html.Lines.Breakeven.newLines = [];
                break;
              default:
                TradingviewChart.Html.Lines.Breakeven.newLines = line;
                break;
            }
          }
          if (TradingviewChart.Html.Chart.seriesObject) {
            TradingviewChart.Html.Lines.Breakeven.create();
          }
        },
      },
      Wallets: {
        hasResults: (hasResults) => {
          noWalletsContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          noActiveOrdersContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          noClosedOrdersContainer.setAttribute(
            "class",
            "d-none text-secondary mt-5"
          );
          if (!hasResults) {
            noWalletsContainer.setAttribute(
              "class",
              "d-block text-secondary mt-5"
            );
            walletsContainer.setAttribute("class", "d-none");
            walletsTable.innerHTML = "";
            return;
          }
          walletsContainer.setAttribute("class", "d-block");
        },
        populate: () => {
          const { wallets } = Current.Orders;
          const tableRows = wallets.reduce((t, order) => {
            const { name, currency, available, frozen } = order;
            const tableRow = `
                <tr>
                  <td scope="row">${name}</th>
                  <td>${currency}</td>
                  <td>${available}</td>
                  <td>${frozen}</td>
                </tr>`;
            return (t += tableRow);
          }, "");
          walletsTable.innerHTML = tableRows;
        },
      },
    },
  };

  // Terminal ===========================
  // cTerminal
  const currentWalletAmt = document.getElementById("currentWalletAmt");
  const walletQuote = document.getElementById("walletQuote");
  const selectTradeCategory = document.getElementById("selectTradeCategory");
  const selectSimpleBuyOrder = document.getElementById("selectSimpleBuyOrder");
  const selectSimpleSellOrder = document.getElementById(
    "selectSimpleSellOrder"
  );
  // Simple
  const simpleContainer = document.getElementById("simpleContainer");
  const simpleForm = document.getElementById("simpleForm");
  const disableForm = document.getElementsByClassName("disableForm");
  const selectSimpleBuyOrderToggle = document.getElementById(
    "selectSimpleBuyOrderToggle"
  );
  const selectSimpleSellOrderToggle = document.getElementById(
    "selectSimpleSellOrderToggle"
  );
  const selectSimpleSide = document.getElementById("selectSimpleSide");
  const simpleTradeType = document.getElementById("simpleTradeType");
  const simpleOrderType = document.getElementById("simpleOrderType");
  const simplePriceA = document.getElementById("simplePriceA");
  const simplePriceAError = document.getElementById("simplePriceAError");
  const simplePriceQuoteA = document.getElementById("simplePriceQuoteA");
  const simplePriceB = document.getElementById("simplePriceB");
  const simplePriceBError = document.getElementById("simplePriceBError");
  const simplePriceQuoteB = document.getElementById("simplePriceQuoteB");
  const simpleSpread = document.getElementById("simpleSpread");
  const simpleNumOrders = document.getElementById("simpleNumOrders");
  const simpleVolCustom = document.getElementById("simpleVolCustom");
  const ladder1 = document.getElementById("ladder1");
  const simpleFundingType = document.getElementById("simpleFundingType");
  const simpleTotal = document.getElementById("simpleTotal");
  const simpleTotalQuote = document.getElementById("simpleTotalQuote");
  const simpleTotalError = document.getElementById("simpleTotalError");
  const simpleFundingSrc = document.getElementById("simpleFundingSrc");
  const simpleFundingSrcQ = document.getElementById("simpleFundingSrcQ");
  const simpleFundingSrcB = document.getElementById("simpleFundingSrcB");
  const simpleApproxBase = document.getElementById("simpleApproxBase");
  const simpleApproxBaseSymbol = document.getElementById(
    "simpleApproxBaseSymbol"
  );
  const simpleApproxBaseError = document.getElementById(
    "simpleApproxBaseError"
  );
  const simpleApproxQuote = document.getElementById("simpleApproxQuote");
  const simpleApproxQuoteSymbol = document.getElementById(
    "simpleApproxQuoteSymbol"
  );
  const simpleApproxQuoteError = document.getElementById(
    "simpleApproxQuoteError"
  );
  const simpleBuySubmit = document.getElementById("simpleBuySubmit");
  const simpleSellSubmit = document.getElementById("simpleSellSubmit");
  // Smart
  const smartContainer = document.getElementById("smartContainer");
  const selectSmartBuyOrderToggle = document.getElementById(
    "selectSmartBuyOrderToggle"
  );
  const selectSmartBuyOrder = document.getElementById("selectSmartBuyOrder");
  const selectSmartSellOrderToggle = document.getElementById(
    "selectSmartSellOrderToggle"
  );
  const selectSmartSellOrder = document.getElementById("selectSmartSellOrder");
  const clearSmartForm = document.getElementById("clearSmartForm");
  const smartForm = document.getElementById("smartForm");
  const selectSmartSide = document.getElementById("selectSmartSide");
  const smartTradeType = document.getElementById("smartTradeType");
  const smartOrderType = document.getElementById("smartOrderType");
  const smartPriceA = document.getElementById("smartPriceA");
  const smartPriceAError = document.getElementById("smartPriceAError");
  const smartPriceQuoteA = document.getElementById("smartPriceQuoteA");
  const smartPriceB = document.getElementById("smartPriceB");
  const smartPriceBError = document.getElementById("smartPriceBError");
  const smartPriceQuoteB = document.getElementById("smartPriceQuoteB");
  const smartSpread = document.getElementById("smartSpread");
  const smartNumOrders = document.getElementById("smartNumOrders");
  const tpShortcut = document.getElementsByClassName("tpShortcut");
  const smartTpCustom = document.getElementById("smartTpCustom");
  const smartTpCustomError = document.getElementById("smartTpCustomError");
  const smartTP = document.getElementById("smartTP");
  const smartTPError = document.getElementById("smartTPError");
  const smartVolCustom = document.getElementById("smartVolCustom");
  const smartFundingType = document.getElementById("smartFundingType");
  const smartTotal = document.getElementById("smartTotal");
  const smartTotalError = document.getElementById("smartTotalError");
  const smartFundingSrc = document.getElementById("smartFundingSrc");
  const smartFundingSrcQ = document.getElementById("smartFundingSrcQ");
  const smartFundingSrcB = document.getElementById("smartFundingSrcB");
  const smartApproxBase = document.getElementById("smartApproxBase");
  const smartApproxBaseError = document.getElementById("smartApproxBaseError");
  const smartApproxBaseSymbol = document.getElementById(
    "smartApproxBaseSymbol"
  );
  const smartApproxQuote = document.getElementById("smartApproxQuote");
  const smartApproxQuoteError = document.getElementById(
    "smartApproxQuoteError"
  );
  const smartApproxQuoteSymbol = document.getElementById(
    "smartApproxQuoteSymbol"
  );
  const smartBuySubmit = document.getElementById("smartBuySubmit");
  const smartSellSubmit = document.getElementById("smartSellSubmit");
  // Both
  const currentSymbol = document.getElementsByClassName("currentSymbol");
  const volShortcut = document.getElementsByClassName("volShortcut");
  const Terminal = {
    init: async () => {
      const apiExists = await Terminal.checkAPI();
      if (apiExists) {
        Orders.Import.calculateBreakEven();
        Terminal.Wallet.getAvailable();
        Terminal.Form.init();
      }
    },
    checkAPI: async () => {
      return new Promise((resolve, reject) => {
        Utility.Server.run()
          .withSuccessHandler((result) => {
            resolve(result);
          })
          .withFailureHandler((err) => {
            reject(err);
          })
          .checkAPI();
      });
    },
    getSymbolReq: () => {
      const { is } = Current.Symbol;
      const { allSymbols } = Markets;
      const [selected] = allSymbols.filter((s) => {
        return s.details.symbol == is;
      });
      const {
        base_min_size,
        quote_increment,
        min_buy_amount,
        min_sell_amount,
        price_min_precision,
        price_max_precision,
      } = selected.details;
      let precision = "0.";
      for (let i = 0; i < price_max_precision; i++) {
        precision += i < price_max_precision - 1 ? "0" : "1";
      }
      Current.Terminal.Validation = {
        minBaseSize: base_min_size,
        minQuoteBuyAmount: min_buy_amount,
        minQuoteSellAmount: min_sell_amount,
        priceMinPrecision: price_min_precision,
        priceMaxPrecision: price_max_precision,
        step: quote_increment,
        minQuoteLadder: 0,
        minBaseLadder: 0,
        precision: precision,
      };
    },
    Form: {
      init: () => {
        Terminal.getSymbolReq();
        const { category } = Current.Terminal;
        const forms = {
          simple: () => {
            Terminal.Form.Simple.setInputReq();
          },
          smart: () => {
            Terminal.Form.Smart.setInputReq();
          },
        };
        Terminal.Form.Util.enable();
        forms[category]();
      },
      switch: () => {
        Current.Terminal.category = selectTradeCategory.value;
        if (selectTradeCategory.value == "simple") {
          smartContainer.setAttribute("class", "d-none");
          simpleContainer.setAttribute("class", "d-block");
          Terminal.Form.Simple.setInputReq();
        } else {
          smartContainer.setAttribute("class", "d-block");
          simpleContainer.setAttribute("class", "d-none");
          Terminal.Form.Smart.setInputReq();
        }
      },
      Util: {
        enable: () => {
          for (const el of disableForm) {
            el.disabled = false;
          }
        },
        disable: () => {
          for (const el of disableForm) {
            el.disabled = true;
          }
        },
        clear: () => {
          const { category } = Current.Terminal;
          if (category == "simple") {
            simplePriceA.value = "";
            simplePriceB.value = "";
            simpleSpread.value = "";
            simpleVolCustom.value = "";
            simpleTotal.value = "";
            simpleApproxBase.value = "";
            simpleApproxQuote.value = "";
            Terminal.Form.Simple.Validation.test(true);
          }
          if (category == "smart") {
            smartPriceA.value = "";
            smartPriceB.value = "";
            smartSpread.value = "";
            smartTpCustom.value = "";
            smartTP.value = "";
            smartVolCustom.value = "";
            smartTotal.value = "";
            smartApproxBase.value = "";
            smartApproxQuote.value = "";
            Terminal.Form.Smart.Validation.test(true);
          }
          TradingviewChart.Html.Lines.Input.newLines = [];
          TradingviewChart.Html.Lines.Input.create();
        },
        prevScientificNot: (key, id) => {
          if (!key) {
            return false;
          }
          const { value } = document.getElementById(id);
          const ignore = ["ArrowUp", "ArrowDown"];
          if (value.toString().length > 10 && ignore.includes(key)) {
            return true;
          }
        },
        convertToUs: (num) => {
          return new Intl.NumberFormat("en-US", {
            maximumSignificantDigits: 10,
          })
            .format(num)
            .replace(/,/g, "");
        },
        setLength: (num, type, returnType = "string") => {
          const { minBaseSize, priceMaxPrecision } =
            Current.Terminal.Validation;
          const types = {
            price: () => {
              return returnType == "string"
                ? num.toFixed(priceMaxPrecision)
                : Number(num.toFixed(priceMaxPrecision));
            },
            quote: () => {
              num = num.toString();
              const dot = num.indexOf(".");
              if (dot == -1) {
                return returnType == "string" ? num : Number(num);
              }
              return returnType == "string"
                ? num.slice(0, dot + priceMaxPrecision + 1)
                : Number(num.slice(0, dot + priceMaxPrecision + 1));
            },
            base: () => {
              if (minBaseSize.includes(".")) {
                return returnType == "string"
                  ? num.toFixed(minBaseSize.split(".")[1].length)
                  : Number(num.toFixed(minBaseSize.split(".")[1].length));
              } else {
                return returnType == "string"
                  ? num.toFixed(minBaseSize.length > 1 ? minBaseSize.length : 0)
                  : Number(
                      num.toFixed(
                        minBaseSize.length > 1 ? minBaseSize.length : 0
                      )
                    );
              }
            },
          };
          return types[type]();
        },
        stayBelowQuoteOrder: (vol, price) => {
          const { setLength } = Terminal.Form.Util;
          const { minBaseSize } = Current.Terminal.Validation;
          let getBaseAmt = setLength(vol / price, "base", "number");
          while (getBaseAmt * price > vol) {
            getBaseAmt = setLength(
              getBaseAmt - Number(minBaseSize),
              "base",
              "number"
            );
          }
          const quote = setLength(price * getBaseAmt, "quote", "number");
          return { bReq: getBaseAmt, qReq: quote };
        },
        stayBelowTotalBase: (vol, price, totalVol, numOrders) => {
          const { setLength } = Terminal.Form.Util;
          const { minBaseSize } = Current.Terminal.Validation;
          let getBaseAmt = setLength(vol, "base", "number");
          while (getBaseAmt * numOrders > totalVol) {
            getBaseAmt = setLength(
              getBaseAmt - Number(minBaseSize),
              "base",
              "number"
            );
          }
          const quote = setLength(price * getBaseAmt, "quote", "number");
          return { bReq: getBaseAmt, qReq: quote };
        },
      },
      Simple: {
        lastFocusID: "simplePriceA",
        timeout: null,
        setInputReq: () => {
          const { quote, base } = Current.Symbol;
          const { buy, sell } = Current.Terminal.wallet;
          const {
            minBaseSize,
            minQuoteBuyAmount,
            precision,
            minBaseLadder,
            minQuoteLadder,
            step,
          } = Current.Terminal.Validation;
          const { side, tradeType, orderType, simpleFundingSrc } =
            Terminal.Form.Simple.InputVal();
          const { setAttr, setText } = TradeUtility.HTML;
          const quoteStep = [simplePriceA, simplePriceB, simpleApproxQuote];
          setAttr(quoteStep, "step", precision);
          setAttr([simpleApproxBase], "step", step);
          const quoteFmt = [simplePriceAError, simplePriceBError];
          const baseFmt = [];
          const minVol = [simpleTotal];

          if (simpleFundingSrc == "quote") {
            setAttr(minVol, "step", precision);
            setAttr(minVol, "placeholder", precision);
            setAttr(minVol, "min", minQuoteBuyAmount);
            quoteFmt.push(simpleTotalError);
          } else {
            setAttr(minVol, "step", step);
            setAttr(minVol, "placeholder", minBaseSize);
            setAttr(minVol, "min", minBaseSize);
            baseFmt.push(simpleTotalError);
          }

          setText(quoteFmt, `Please use format: ${precision}`);
          setText(baseFmt, `Please use format: ${minBaseSize}`);
          if (orderType == "limit") {
            setAttr(
              [simpleApproxBase],
              "min",
              tradeType == "single" ? minBaseSize : minBaseLadder
            );
            setAttr(
              [simpleApproxQuote],
              "min",
              tradeType == "single" ? minQuoteBuyAmount : minQuoteLadder
            );
          } else {
            if (side == "buy") {
              setAttr([simpleApproxBase], "min", 0);
              setAttr([simpleApproxQuote], "min", minQuoteBuyAmount);
            } else {
              setAttr([simpleApproxQuote], "min", 0);
              setAttr([simpleApproxBase], "min", minBaseSize);
            }
          }

          const quoteText = [
            simplePriceQuoteA,
            simplePriceQuoteB,
            simpleFundingSrcQ,
            simpleApproxQuoteSymbol,
          ];
          const baseText = [simpleFundingSrcB, simpleApproxBaseSymbol];
          side == "buy"
            ? quoteText.push(walletQuote)
            : baseText.push(walletQuote);
          setText(quoteText, quote);
          setText(baseText, base);
        },
        runHtml: (event) => {
          const { Simple } = Terminal.Form;
          const { Inputs } = Simple;
          Inputs[event.target.id].html(event);
        },
        runCalc: (event) => {
          const { Simple } = Terminal.Form;
          const { Inputs } = Simple;
          clearTimeout(Simple.timeout);
          Simple.timeout = setTimeout(() => {
            Inputs[typeof event == "string" ? event : event.target.id].calc(
              event
            );
            Simple.Validation.test();
            TradingviewChart.Html.Lines.Input.create();
          }, 100);
        },
        InputVal: () => {
          return {
            side: selectSimpleSide.value,
            tradeType: simpleTradeType.value,
            orderType: simpleOrderType.value,
            priceA: Number(simplePriceA.value),
            priceB: Number(simplePriceB.value),
            simpleNumOrders: Number(simpleNumOrders.value),
            simpleVolCustom: Number(simpleVolCustom.value),
            simpleFundingType: simpleFundingType.value,
            simpleTotal: Number(simpleTotal.value),
            simpleFundingSrc: simpleFundingSrc.value,
            simpleApproxBase: Number(simpleApproxBase.value),
            simpleApproxQuote: Number(simpleApproxQuote.value),
          };
        },
        calcLadderOrders: () => {
          const { Simple, Util } = Terminal.Form;
          const { setLength, stayBelowQuoteOrder, stayBelowTotalBase } = Util;
          const { setAttr } = TradeUtility.HTML;
          const {
            tradeType,
            priceA,
            priceB,
            simpleNumOrders,
            simpleFundingType,
            simpleFundingSrc,
            simpleTotal,
          } = Simple.InputVal();
          const {
            minBaseSize,
            minQuoteBuyAmount,
            minBaseLadder,
            minQuoteLadder,
            priceMaxPrecision,
          } = Current.Terminal.Validation;
          const fns = {
            calcLadderPrices: (a, b, n) => {
              const start = a > b ? a : b;
              const stop = a > b ? b : a;
              const linear = (start - stop) / (n - 1);
              const prices = [Number(start).toFixed(priceMaxPrecision)];
              for (let i = 0; i < n - 2; i++) {
                const p = prices[i == 0 ? 0 : prices.length - 1] - linear;
                prices.push(Number(p).toFixed(priceMaxPrecision));
              }
              prices.push(Number(stop).toFixed(priceMaxPrecision));
              return prices;
            },
            setMinLadderVolReq: (prices) => {
              const minPrecisionCheck = (minQuoteBuyAmount, price) => {
                let getBaseAmt = setLength(
                  Number(minQuoteBuyAmount) / price,
                  "base",
                  "number"
                );
                while (getBaseAmt * price < minQuoteBuyAmount) {
                  getBaseAmt = setLength(
                    Number(minBaseSize) + getBaseAmt,
                    "base",
                    "number"
                  );
                }
                const quote = setLength(price * getBaseAmt, "quote", "number");
                return { bReq: getBaseAmt, qReq: quote };
              };
              const minReqAmounts = prices.reduce(
                (t, p) => {
                  const { bReq, qReq } = minPrecisionCheck(
                    minQuoteBuyAmount,
                    Number(p)
                  );
                  t.b += bReq;
                  t.q += qReq;
                  return t;
                },
                { b: 0, q: 0 }
              );
              const minQuoteReq = setLength(minReqAmounts.q, "quote", "number");
              const minBaseReq = setLength(minReqAmounts.b, "base", "number");
              Current.Terminal.Validation.minQuoteLadder = minQuoteReq;
              Current.Terminal.Validation.minBaseLadder = minBaseReq;
              setAttr([simpleApproxBase], "min", minBaseReq);
              setAttr([simpleApproxQuote], "min", minQuoteReq);
            },
            quote: {
              total: (prices, totalVol) => {
                const orderVol = totalVol / Number(simpleNumOrders);
                const orders = prices.map((p) => {
                  const { bReq, qReq } = stayBelowQuoteOrder(
                    orderVol,
                    Number(p)
                  );
                  const o = {
                    price: p,
                    bVol: bReq,
                    qVol: qReq,
                    isQError: false,
                    isBError: false,
                  };
                  if (qReq < minQuoteBuyAmount) {
                    o.isQError = true;
                  }
                  if (bReq < Number(minBaseSize)) {
                    o.isBError = true;
                  }
                  return o;
                });
                return orders;
              },
              each: (prices, orderVol) => {
                const orders = prices.map((p) => {
                  const { bReq, qReq } = stayBelowQuoteOrder(
                    orderVol,
                    Number(p)
                  );
                  const o = {
                    price: p,
                    bVol: bReq,
                    qVol: qReq,
                    isQError: false,
                    isBError: false,
                  };
                  if (qReq < minQuoteBuyAmount) {
                    o.isQError = true;
                  }
                  if (bReq < Number(minBaseSize)) {
                    o.isBError = true;
                  }
                  return o;
                });
                return orders;
              },
            },
            base: {
              total: (prices, totalVol) => {
                const orderVol = totalVol / Number(simpleNumOrders);
                const orders = prices.map((p) => {
                  const { bReq, qReq } = stayBelowTotalBase(
                    orderVol,
                    Number(p),
                    totalVol,
                    Number(simpleNumOrders)
                  );
                  const o = {
                    price: p,
                    bVol: bReq,
                    qVol: qReq,
                    isQError: false,
                    isBError: false,
                  };
                  if (qReq < minQuoteBuyAmount) {
                    o.isQError = true;
                  }
                  if (bReq < Number(minBaseSize)) {
                    o.isBError = true;
                  }
                  return o;
                });
                return orders;
              },
              each: (prices, orderVol) => {
                const orders = prices.map((p) => {
                  const qVol = setLength(
                    Number(orderVol) * Number(p),
                    "quote",
                    "number"
                  );
                  const o = {
                    price: p,
                    bVol: Number(orderVol),
                    qVol,
                    isQError: false,
                    isBError: false,
                  };
                  if (qVol < minQuoteBuyAmount) {
                    o.isQError = true;
                  }
                  return o;
                });
                return orders;
              },
            },
            calcApproxTotals: (orders) => {
              const totals = orders.reduce(
                (t, o) => {
                  t.quote += Number(o.qVol);
                  t.base += Number(o.bVol);
                  return t;
                },
                { quote: 0, base: 0 }
              );
              totals.quote = setLength(totals.quote, "quote", "number");
              totals.base = setLength(totals.base, "base", "number");
              return totals;
            },
            convertToLines: (orders, base = true) => {
              const { Lines } = TradingviewChart.Html;
              const { Input } = Lines;
              const isBase = base ? "base" : "tp";
              Input.newLines = orders.map((p, i) => {
                const { price, bVol, isQError, isBError } = p;
                const line = {
                  id: 0,
                  price: setLength(price, "quote", "number"),
                  lineType: "innerPrice",
                  where: "ladderPrice",
                  tradeType: "ladder",
                  amt: bVol,
                  whichOrder: isBase,
                  isFinished: false,
                };
                if (i == 0) {
                  line.lineType = "outerPrice";
                }
                if (i == orders.length - 1) {
                  line.lineType = "outerPrice";
                }
                if (isQError || isBError) {
                  line.lineType = "isError";
                  line.amt = "Below Min Required";
                }
                return Lines.newLine(line);
              });
            },
          };
          const prices = fns.calcLadderPrices(priceA, priceB, simpleNumOrders);
          fns.setMinLadderVolReq(prices);
          const orders = fns[simpleFundingSrc][simpleFundingType](
            prices,
            simpleTotal
          );
          const approxTotals = fns.calcApproxTotals(orders);
          simpleApproxBase.value = approxTotals.base;
          simpleApproxQuote.value = approxTotals.quote;
          fns.convertToLines(orders);
          Current.Terminal.orders = orders;
        },
        Inputs: {
          selectSimpleBuyOrder: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              TradingviewChart.Html.Lines.Input.changeSide();
              Terminal.Wallet.getAvailableQuote();
              Terminal.Form.Simple.Inputs.simpleFundingSrc.switch("quote");
            },
            html: () => {
              selectSimpleSide.value = "buy";
              simpleBuySubmit.setAttribute(
                "class",
                "d-block btn btn-success no-focus"
              );
              simpleSellSubmit.setAttribute("class", "d-none");
              selectSimpleBuyOrderToggle.setAttribute(
                "class",
                `d-grid gap-0 buy text-success toggle selected`
              );
              selectSimpleSellOrderToggle.setAttribute(
                "class",
                `d-grid gap-0 sell text-secondary toggle`
              );
              walletQuote.innerText = Current.Symbol.quote;
            },
          },
          selectSimpleSellOrder: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              TradingviewChart.Html.Lines.Input.changeSide();
              Terminal.Wallet.getAvailableBase();
              Terminal.Form.Simple.Inputs.simpleFundingSrc.switch("base");
            },
            html: () => {
              selectSimpleSide.value = "sell";
              simpleSellSubmit.setAttribute(
                "class",
                "d-block btn btn-danger no-focus"
              );
              simpleBuySubmit.setAttribute("class", "d-none");
              selectSimpleSellOrderToggle.setAttribute(
                "class",
                `d-grid gap-0 sell text-danger toggle selected`
              );
              selectSimpleBuyOrderToggle.setAttribute(
                "class",
                `d-grid gap-0 buy text-secondary toggle`
              );
              walletQuote.innerText = Current.Symbol.base;
            },
          },
          simpleTradeType: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              const { tradeType } = Terminal.Form.Simple.InputVal();
              const types = {
                single: () => {
                  simplePriceA.required = true;
                  simplePriceA.focus();
                  simplePriceB.value = "";
                  simplePriceB.disabled = true;
                  simplePriceB.required = false;
                  simpleFundingSrc.disabled = true;
                  simpleNumOrders.disabled = true;
                  simpleNumOrders.value = "1";
                  ladder1.disabled = false;
                  simpleOrderType.disabled = false;
                  simpleFundingType.value = "total";
                  simpleFundingType.disabled = true;
                  simpleTotal.required = true;
                },
                ladder: () => {
                  simplePriceA.disabled = false;
                  simplePriceA.required = true;
                  simplePriceB.required = true;
                  simplePriceB.disabled = false;
                  simpleNumOrders.disabled = false;
                  simpleOrderType.value = "limit";
                  simpleNumOrders.value = "10";
                  ladder1.disabled = true;
                  simpleFundingType.disabled = false;
                  simpleOrderType.disabled = true;
                },
              };
              types[tradeType]();
            },
            html: () => {
              Terminal.Form.Util.clear();
              Terminal.Form.Simple.setInputReq();
            },
          },
          simpleOrderType: {
            checkConditions: (clear) => {
              const { Simple } = Terminal.Form;
              const { orderType } = Simple.InputVal();
              const { updateHTML } = Simple.Validation;
              const orderTypes = {
                limit: () => {},
                market: () => {},
              };
              orderTypes[orderType]();
            },
            calc: () => {
              const { Simple } = Terminal.Form;
              const { orderType } = Simple.InputVal();
              const { minBaseSize, minQuoteBuyAmount } =
                Current.Terminal.Validation;
              const orderTypes = {
                limit: () => {},
                market: () => {
                  Simple.runCalc("simpleTotal");
                },
              };
              Simple.setInputReq();
              orderTypes[orderType]();
            },
            html: () => {
              const { orderType, side } = Terminal.Form.Simple.InputVal();
              const types = {
                limit: () => {
                  simplePriceA.required = true;
                  simplePriceA.disabled = false;
                  simplePriceA.value = "";
                  simplePriceB.disabled = true;
                  simplePriceB.value = "";
                  simpleFundingSrc.disabled = false;
                  simplePriceA.focus();
                },
                market: () => {
                  simplePriceA.required = false;
                  simplePriceA.value = "";
                  simplePriceB.value = "";
                  simplePriceA.disabled = true;
                  simplePriceB.disabled = true;
                  if (side == "buy") {
                    simpleFundingSrc.value = "quote";
                  } else {
                    simpleFundingSrc.value = "base";
                  }
                  simpleFundingSrc.disabled = true;
                  simpleTotal.focus();
                  const { value } = simpleTotal;
                  simpleTotal.value = "";
                  simpleTotal.value = value;
                },
              };
              types[orderType]();
            },
          },
          simplePriceA: {
            errors: () => {
              return {
                inputId: simplePriceA,
                errorId: simplePriceAError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm input-focus",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { priceMaxPrecision } = Current.Terminal.Validation;
              const { Simple, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { tradeType, orderType, priceA, priceB } =
                Simple.InputVal();
              const { updateHTML } = Simple.Validation;
              updateHTML("simplePriceA");
              if (clear || !priceA) {
                return;
              }
              const orderTypes = {
                limit: () => {
                  if (!priceA) {
                    updateHTML("simplePriceA", true, "quote", "min");
                  }
                  const dot = convertToUs(priceA).indexOf(".");
                  if (dot > -1) {
                    const split = convertToUs(priceA).split(".");
                    if (split[1].length > priceMaxPrecision) {
                      updateHTML("simplePriceA", true, "quote", "format");
                    }
                  }
                },
                market: () => {},
              };
              const tradeTypes = {
                single: () => {
                  orderTypes[orderType]();
                },
                ladder: () => {
                  orderTypes.limit();
                },
              };
              tradeTypes[tradeType]();
            },
            calc: () => {
              const { Simple, Util } = Terminal.Form;
              const {
                priceA,
                priceB,
                simpleTotal,
                tradeType,
                simpleFundingSrc,
              } = Simple.InputVal();
              const { setLength, stayBelowQuoteOrder, convertToUs } = Util;
              const tradeTypes = {
                single: () => {
                  if (!priceA || !simpleTotal) {
                    return;
                  }
                  let base, quote;
                  if (simpleFundingSrc == "quote") {
                    const { bReq, qReq } = stayBelowQuoteOrder(
                      simpleTotal,
                      priceA
                    );
                    quote = qReq;
                    base = bReq;
                  } else {
                    base = setLength(simpleTotal, "base", "number");
                    quote = setLength(base * priceA, "quote", "number");
                  }
                  simpleApproxQuote.value = convertToUs(quote);
                  simpleApproxBase.value = convertToUs(base);
                  const { Lines } = TradingviewChart.Html;
                  const { Input } = Lines;
                  Input.newLines = [
                    Lines.newLine({
                      id: 0,
                      price: priceA,
                      where: "simplePriceA",
                      tradeType: "single",
                      amt: base,
                      whichOrder: "base",
                      isFinished: false,
                    }),
                  ];
                },
                ladder: () => {
                  if (!priceA || !priceB) {
                    simpleSpread.value = "";
                    return;
                  }
                  Simple.calcLadderOrders();
                  const sprd = (
                    ((Number(priceA) - Number(priceB)) / Number(priceA)) *
                    100
                  ).toFixed(4);
                  simpleSpread.value = convertToUs(sprd);
                },
              };
              tradeTypes[tradeType]();
            },
            html: () => {
              Terminal.Form.Simple.lastFocusID = "simplePriceA";
            },
          },
          simplePriceB: {
            errors: () => {
              return {
                inputId: simplePriceB,
                errorId: simplePriceBError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm input-focus",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { priceMaxPrecision } = Current.Terminal.Validation;
              const { Simple, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { tradeType, orderType, priceB } = Simple.InputVal();
              const { updateHTML } = Simple.Validation;
              updateHTML("simplePriceB");
              if (clear || !priceB) {
                return;
              }
              const orderTypes = {
                limit: () => {
                  if (!priceB) {
                    updateHTML("simplePriceB", true, "quote", "min");
                  }
                  const dot = convertToUs(priceB).indexOf(".");
                  if (dot > -1) {
                    const split = convertToUs(priceB).split(".");
                    if (split[1].length > priceMaxPrecision) {
                      updateHTML("simplePriceB", true, "quote", "format");
                    }
                  }
                },
                market: () => {},
              };
              const tradeTypes = {
                single: () => {},
                ladder: () => {
                  orderTypes.limit();
                },
              };
              tradeTypes[tradeType]();
            },
            calc: () => {
              const { Simple, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { tradeType, priceA, priceB } = Simple.InputVal();
              const tradeTypes = {
                single: () => {},
                ladder: () => {
                  if (!priceA || !priceB) {
                    simpleSpread.value = "";
                    return;
                  }
                  Simple.calcLadderOrders();
                  const sprd = (
                    ((Number(priceA) - Number(priceB)) / Number(priceA)) *
                    100
                  ).toFixed(4);
                  simpleSpread.value = convertToUs(sprd);
                },
              };
              tradeTypes[tradeType]();
            },
            html: () => {
              Terminal.Form.Simple.lastFocusID = "simplePriceB";
            },
          },
          simpleNumOrders: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              const { Simple } = Terminal.Form;
              const { tradeType } = Simple.InputVal();
              const tradeTypes = {
                single: () => {},
                ladder: () => {
                  Simple.calcLadderOrders();
                },
              };
              tradeTypes[tradeType]();
            },
          },
          simpleFundingType: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              const { Simple } = Terminal.Form;
              const { tradeType } = Simple.InputVal();
              const tradeTypes = {
                single: () => {},
                ladder: () => {
                  Simple.calcLadderOrders();
                },
              };
              tradeTypes[tradeType]();
            },
          },
          simpleFundingSrc: {
            checkConditions: (clear) => {},
            html: () => {
              Terminal.Form.Simple.setInputReq();
            },
            switch: (which) => {
              simpleFundingSrc.value = which;
              Terminal.Form.Simple.setInputReq();
            },
            calc: () => {
              const { Simple, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const {
                tradeType,
                orderType,
                simpleFundingSrc,
                simpleApproxQuote,
                simpleApproxBase,
              } = Simple.InputVal();
              const { minBaseSize, minQuoteBuyAmount } =
                Current.Terminal.Validation;
              const tradeTypes = {
                single: () => {
                  const orderTypes = {
                    limit: () => {
                      if (simpleFundingSrc == "quote") {
                        simpleTotal.value = convertToUs(simpleApproxQuote);
                      } else {
                        simpleTotal.value = convertToUs(simpleApproxBase);
                      }
                    },
                    market: () => {},
                  };
                  orderTypes[orderType]();
                },
                ladder: () => {
                  if (simpleFundingSrc == "quote") {
                    simpleTotal.value = convertToUs(simpleApproxQuote);
                  } else {
                    simpleTotal.value = convertToUs(simpleApproxBase);
                  }
                  Simple.calcLadderOrders();
                },
              };
              tradeTypes[tradeType]();
              simpleTotal.focus();
            },
          },
          simpleCustomPreset: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: (event) => {
              const { category } = Current.Terminal;
              const { Simple, Util } = Terminal.Form;
              const { setLength, convertToUs } = Util;
              const { side, simpleFundingSrc } = Simple.InputVal();
              const { volShortcut } = event.target.dataset;
              const { wallet } = Current.Terminal;
              if (category !== "simple") {
                return;
              }
              if (side == "buy") {
                if (simpleFundingSrc == "quote" && wallet.buy > 0) {
                  simpleTotal.value = convertToUs(
                    setLength(
                      Number(volShortcut) * wallet.buy,
                      "quote",
                      "number"
                    )
                  );
                  Simple.runCalc("simpleTotal");
                }
              } else {
                if (simpleFundingSrc == "base" && wallet.sell > 0) {
                  simpleTotal.value = convertToUs(
                    setLength(
                      Number(volShortcut) * wallet.sell,
                      "base",
                      "number"
                    )
                  );
                  Simple.runCalc("simpleTotal");
                }
              }
            },
          },
          simpleVolCustom: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              const { Simple, Util } = Terminal.Form;
              const { setLength, convertToUs } = Util;
              const { side, simpleFundingSrc, simpleVolCustom } =
                Simple.InputVal();
              const { wallet } = Current.Terminal;
              if (side == "buy") {
                if (simpleFundingSrc == "quote" && simpleVolCustom > 0) {
                  simpleTotal.value = convertToUs(
                    setLength(
                      (simpleVolCustom / 100) * wallet.buy,
                      "quote",
                      "number"
                    )
                  );
                  Simple.runCalc("simpleTotal");
                }
              } else {
                if (simpleFundingSrc == "base" && simpleVolCustom > 0) {
                  simpleTotal.value = convertToUs(
                    setLength(
                      (simpleVolCustom / 100) * wallet.sell,
                      "base",
                      "number"
                    )
                  );
                  Simple.runCalc("simpleTotal");
                }
              }
            },
          },
          simpleTotal: {
            errors: () => {
              const { Simple } = Terminal.Form;
              const { simpleApproxBase, simpleApproxQuote } = Simple.InputVal();
              return {
                inputId: simpleTotal,
                errorId: simpleTotalError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm input-focus",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Min Quote Size: ${Current.Terminal.Validation.minQuoteBuyAmount}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                      base: {
                        min: `Min Base Size: ${Current.Terminal.Validation.minBaseSize}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.minBaseSize}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Should be ~: ${
                          Current.Terminal.Validation.minQuoteLadder *
                          (1 + 0.034)
                        }`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                      base: {
                        min: `Min Base Size: ${
                          Current.Terminal.Validation.minBaseLadder *
                          (1 + 0.034)
                        }`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.minBaseSize}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Min Quote Size: ${Current.Terminal.Validation.minQuoteBuyAmount}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                      base: {
                        min: `Min Base Size: ${Current.Terminal.Validation.minBaseSize}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.minBaseSize}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { Simple, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { updateHTML } = Simple.Validation;
              const {
                priceMaxPrecision,
                minQuoteBuyAmount,
                minQuoteLadder,
                minBaseSize,
                minBaseLadder,
              } = Current.Terminal.Validation;
              const { wallet } = Current.Terminal;
              const {
                tradeType,
                orderType,
                simpleFundingType,
                simpleFundingSrc,
                simpleTotal,
              } = Simple.InputVal();
              updateHTML("simpleTotal");
              if (clear || !simpleTotal) {
                return;
              }
              const checks = {
                min: () => {
                  const opts = {
                    single: {
                      total: {
                        quote: Number(minQuoteBuyAmount),
                        base: Number(minBaseSize),
                      },
                    },
                    ladder: {
                      total: {
                        quote: minQuoteLadder,
                        base: minBaseLadder,
                      },
                      each: {
                        quote: Number(minQuoteBuyAmount),
                        base: Number(minBaseSize),
                      },
                    },
                  };
                  const minAmt =
                    opts[tradeType][simpleFundingType][simpleFundingSrc];
                  if (Number(simpleTotal) < minAmt) {
                    updateHTML("simpleTotal", true, simpleFundingSrc, "min");
                  }
                },
                decimal: () => {
                  let precision;
                  if (simpleFundingSrc == "quote") {
                    precision = priceMaxPrecision;
                  } else {
                    if (minBaseSize.includes(".")) {
                      precision = minBaseSize.split(".")[1].length;
                    } else {
                      precision = minBaseSize;
                    }
                  }
                  const dot = convertToUs(simpleTotal).indexOf(".");
                  if (dot > -1) {
                    const split = convertToUs(simpleTotal).split(".");
                    if (split[1].length > precision) {
                      updateHTML(
                        "simpleTotal",
                        true,
                        simpleFundingSrc,
                        "format"
                      );
                    }
                  }
                },
              };
              checks.decimal();
              checks.min();
            },
            calc: () => {
              const { Simple, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const {
                tradeType,
                orderType,
                side,
                priceA,
                simpleFundingSrc,
                simpleTotal,
              } = Simple.InputVal();
              const tradeTypes = {
                single: () => {
                  const orderTypes = {
                    limit: () => {
                      if (!simpleTotal) {
                        simpleApproxBase.value = 0;
                        simpleApproxQuote.value = 0;
                      }
                      Simple.runCalc("simplePriceA");
                    },
                    market: () => {
                      if (side == "buy") {
                        simpleApproxBase.value = 0;
                        simpleApproxQuote.value = convertToUs(simpleTotal);
                      } else {
                        simpleApproxBase.value = convertToUs(simpleTotal);
                        simpleApproxQuote.value = 0;
                      }
                    },
                  };
                  orderTypes[orderType]();
                },
                ladder: () => {
                  Simple.calcLadderOrders();
                },
              };
              tradeTypes[tradeType]();
            },
          },
          simpleApproxBase: {
            errors: () => {
              const { setLength } = Terminal.Form.Util;
              const simpleApproxB =
                Terminal.Form.Simple.InputVal().simpleApproxBase;
              const {
                minQuoteBuyAmount,
                minBaseSize,
                minQuoteLadder,
                minBaseLadder,
                precision,
                step,
              } = Current.Terminal.Validation;
              const diff = (source, target) => {
                return setLength(Number(source) - Number(target), "base");
              };
              return {
                inputId: simpleApproxBase,
                errorId: simpleApproxBaseError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Min Req: ${minQuoteBuyAmount} | Inc By: ${diff(
                          minQuoteBuyAmount,
                          simpleApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseSize} | Inc By: ${diff(
                          minBaseSize,
                          simpleApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                        mod: `Must end with step: ${step}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Min Req: ${minQuoteLadder} | Inc By: ${diff(
                          minQuoteLadder,
                          simpleApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseLadder} | Inc By: ${diff(
                          minBaseLadder,
                          simpleApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                        mod: `Must end with step: ${step}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Min Req: ${minQuoteBuyAmount} | Inc By: ${diff(
                          minQuoteBuyAmount,
                          simpleApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseSize} | Inc By: ${diff(
                          minBaseSize,
                          simpleApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                        mod: `Must end with step: ${step}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { minBaseSize, minBaseLadder, step } =
                Current.Terminal.Validation;
              const { wallet } = Current.Terminal;
              const { Simple } = Terminal.Form;
              const { updateHTML } = Simple.Validation;
              const {
                side,
                tradeType,
                orderType,
                simpleApproxBase,
                simpleFundingType,
              } = Simple.InputVal();
              updateHTML("simpleApproxBase");
              if (clear || !simpleApproxBase) {
                return;
              }
              const checks = {
                min: () => {
                  const opts = {
                    single: {
                      total: {
                        base: Number(minBaseSize),
                      },
                    },
                    ladder: {
                      total: {
                        base: minBaseLadder,
                      },
                      each: {
                        base: Number(minBaseSize),
                      },
                    },
                  };
                  const minAmt = opts[tradeType][simpleFundingType].base;
                  if (
                    orderType == "limit" &&
                    Number(simpleApproxBase) < minAmt
                  ) {
                    updateHTML("simpleApproxBase", true, "base", "min");
                  }
                },
                max: () => {
                  if (simpleApproxBase > wallet.sell && side == "sell") {
                    updateHTML("simpleApproxBase", true, "quote", "max");
                  }
                },
                mod: () => {
                  if (simpleApproxBase % Number(step)) {
                    updateHTML("simpleApproxBase", true, "base", "mod");
                  }
                },
              };
              checks.min();
              checks.max();
              //checks.mod();
            },
            html: (event) => {
              event.preventDefault();
              event.stopPropagation();
              simpleApproxBase.focus();
              simpleApproxBase.select();
              document.execCommand("copy");
              return false;
            },
            calc: () => {},
          },
          simpleApproxQuote: {
            errors: () => {
              const { setLength } = Terminal.Form.Util;
              const simpleApproxQ =
                Terminal.Form.Simple.InputVal().simpleApproxQuote;
              const {
                minQuoteBuyAmount,
                minBaseSize,
                minQuoteLadder,
                minBaseLadder,
                precision,
              } = Current.Terminal.Validation;
              const diff = (source, target) => {
                return setLength(Number(source) - Number(target), "quote");
              };
              return {
                inputId: simpleApproxQuote,
                errorId: simpleApproxQuoteError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Min Req: ${minQuoteBuyAmount} | Inc By: ${diff(
                          minQuoteBuyAmount,
                          simpleApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseSize} | Inc By: ${diff(
                          minBaseSize,
                          simpleApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Min Req: ${minQuoteLadder} | Inc By: ${diff(
                          minQuoteLadder,
                          simpleApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseLadder} | Inc By: ${diff(
                          minBaseLadder,
                          simpleApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Min Req: ${minQuoteBuyAmount} | Inc By: ${diff(
                          minQuoteBuyAmount,
                          simpleApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseSize} | Inc By: ${diff(
                          minBaseSize,
                          simpleApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { minQuoteBuyAmount, minQuoteLadder } =
                Current.Terminal.Validation;
              const { wallet } = Current.Terminal;
              const { Simple } = Terminal.Form;
              const { updateHTML } = Simple.Validation;
              const {
                side,
                tradeType,
                orderType,
                simpleApproxQuote,
                simpleFundingType,
              } = Simple.InputVal();
              updateHTML("simpleApproxQuote");
              if (clear || !simpleApproxQuote) {
                return;
              }
              const checks = {
                min: () => {
                  const opts = {
                    single: {
                      total: {
                        quote: Number(minQuoteBuyAmount),
                      },
                    },
                    ladder: {
                      total: {
                        quote: minQuoteLadder,
                      },
                      each: {
                        quote: Number(minQuoteBuyAmount),
                      },
                    },
                  };
                  const minAmt = opts[tradeType][simpleFundingType].quote;
                  if (
                    orderType == "limit" &&
                    Number(simpleApproxQuote) < minAmt
                  ) {
                    updateHTML("simpleApproxQuote", true, "quote", "min");
                  }
                },
                max: () => {
                  if (simpleApproxQuote > wallet.buy && side == "buy") {
                    updateHTML("simpleApproxQuote", true, "quote", "max");
                  }
                },
              };
              checks.min();
              checks.max();
            },
            html: (event) => {
              event.preventDefault();
              event.stopPropagation();
              simpleApproxQuote.focus();
              simpleApproxQuote.select();
              document.execCommand("copy");
              return false;
            },
            calc: () => {},
          },
        },
        Validation: {
          test: (clear = false) => {
            const { Inputs } = Terminal.Form.Simple;
            for (const key in Inputs) {
              if (Object.hasOwnProperty.call(Inputs, key)) {
                if ("calc" in Inputs[key]) {
                  Inputs[key].checkConditions(clear);
                }
              }
            }
          },
          updateHTML: (where, isError = false, simpleFundingSrc, text) => {
            const { Simple } = Terminal.Form;
            const { tradeType, simpleFundingType } = Simple.InputVal();
            const e = Simple.Inputs[where].errors();
            if (!isError) {
              e.inputId.setAttribute("class", e.class.resolved);
              return;
            }
            e.inputId.setAttribute("class", e.class.error);
            e.errorId.innerText =
              e.msg[tradeType][simpleFundingType][simpleFundingSrc][text];
          },
        },
        submitSimpleOrder: (event) => {
          event.preventDefault();
          const form = event.target;
          event.target.reportValidity();
          if (event.target.checkValidity()) {
            let text, btn;
            if (selectSimpleSide.value == "buy") {
              text = "Buy";
              btn = "simpleBuySubmit";
            } else {
              text = "Sell";
              btn = "simpleSellSubmit";
            }
            const serialized = $(simpleForm).serializeArray();
            serialized.push({
              name: "orders",
              value: Current.Terminal.orders,
            });
            const readyToSend = serialized.reduce((t, el) => {
              t[el.name] = el.value;

              return t;
            }, {});
            Utility.Page.loading(btn, true, "center", "small", true);
            Utility.Server.run()
              .withSuccessHandler((result) => {
                Utility.Page.loading(btn, false, null, null, null, text);
                if (result) {
                  Orders.update();
                  Terminal.Wallet.getAvailable();
                  TradingviewChart.Html.Lines.Input.newLines = [];
                  TradingviewChart.Html.Lines.Input.create();
                  TradingviewChart.Html.Markers.create();
                }
              })
              .withFailureHandler((err) => {
                Utility.Page.loading(btn, false, null, null, null, text);
                TradeUtility.Page.errResponses(err);
                Orders.update();
                Terminal.Wallet.getAvailable();
                TradingviewChart.Html.Lines.Input.newLines = [];
                TradingviewChart.Html.Lines.Input.create();
              })
              .submitSimpleOrder(readyToSend);
          } else {
            Terminal.Form.Simple.Validation.test();
            event.stopPropagation();
          }
        },
      },
      Smart: {
        lastFocusID: "smartPriceA",
        timeout: null,
        setInputReq: () => {
          const { quote, base } = Current.Symbol;
          const { buy, sell } = Current.Terminal.wallet;
          const {
            minBaseSize,
            minQuoteBuyAmount,
            precision,
            minBaseLadder,
            minQuoteLadder,
            step,
          } = Current.Terminal.Validation;
          const { side, tradeType, orderType, smartFundingSrc } =
            Terminal.Form.Smart.InputVal();
          const { setAttr, setText } = TradeUtility.HTML;
          const quoteStep = [
            smartPriceA,
            smartPriceB,
            smartTP,
            smartApproxQuote,
          ];
          setAttr(quoteStep, "step", precision);
          setAttr([smartApproxBase], "step", step);
          const quoteFmt = [smartPriceAError, smartPriceBError, smartTPError];
          const baseFmt = [];
          const minVol = [smartTotal];

          setAttr([smartTP], "placeholder", precision);

          if (smartFundingSrc == "quote") {
            setAttr(minVol, "step", precision);
            setAttr(minVol, "placeholder", precision);
            setAttr(minVol, "min", minQuoteBuyAmount);
            quoteFmt.push(smartTotalError);
          } else {
            setAttr(minVol, "step", step);
            setAttr(minVol, "placeholder", minBaseSize);
            setAttr(minVol, "min", minBaseSize);
            baseFmt.push(smartTotalError);
          }

          setText(quoteFmt, `Please use format: ${precision}`);
          setText(baseFmt, `Please use format: ${minBaseSize}`);
          if (orderType == "limit") {
            setAttr(
              [smartApproxBase],
              "min",
              tradeType == "single" ? minBaseSize : minBaseLadder
            );
            setAttr(
              [smartApproxQuote],
              "min",
              tradeType == "single" ? minQuoteBuyAmount : minQuoteLadder
            );
          } else {
            if (side == "buy") {
              setAttr([smartApproxBase], "min", 0);
              setAttr([smartApproxQuote], "min", minQuoteBuyAmount);
            } else {
              setAttr([smartApproxQuote], "min", 0);
              setAttr([smartApproxBase], "min", minBaseSize);
            }
          }

          const quoteText = [
            smartPriceQuoteA,
            smartPriceQuoteB,
            smartFundingSrcQ,
            smartApproxQuoteSymbol,
          ];
          const baseText = [smartFundingSrcB, smartApproxBaseSymbol];
          side == "buy"
            ? quoteText.push(walletQuote)
            : baseText.push(walletQuote);
          setText(quoteText, quote);
          setText(baseText, base);
        },
        runHtml: (event) => {
          const { Smart } = Terminal.Form;
          const { Inputs } = Smart;
          Inputs[event.target.id].html(event);
        },
        runCalc: (event) => {
          const { Smart } = Terminal.Form;
          const { Inputs } = Smart;
          clearTimeout(Smart.timeout);
          Smart.timeout = setTimeout(() => {
            Inputs[typeof event == "string" ? event : event.target.id].calc(
              event
            );
            Smart.Validation.test();
            TradingviewChart.Html.Lines.Input.create();
          }, 100);
        },
        InputVal: () => {
          return {
            side: selectSmartSide.value,
            tradeType: smartTradeType.value,
            orderType: smartOrderType.value,
            priceA: Number(smartPriceA.value),
            priceB: Number(smartPriceB.value),
            smartNumOrders: Number(smartNumOrders.value),
            smartTP: Number(smartTP.value),
            smartTpCustom: Number(smartTpCustom.value),
            smartVolCustom: Number(smartVolCustom.value),
            smartFundingType: smartFundingType.value,
            smartTotal: Number(smartTotal.value),
            smartFundingSrc: smartFundingSrc.value,
            smartApproxBase: Number(smartApproxBase.value),
            smartApproxQuote: Number(smartApproxQuote.value),
          };
        },
        calcLadderOrders: () => {
          const { Smart, Util } = Terminal.Form;
          const { setLength, stayBelowQuoteOrder, stayBelowTotalBase } = Util;
          const { setAttr } = TradeUtility.HTML;
          const {
            tradeType,
            side,
            priceA,
            priceB,
            smartNumOrders,
            smartTpCustom,
            smartFundingType,
            smartFundingSrc,
            smartTotal,
          } = Smart.InputVal();
          const {
            minBaseSize,
            minQuoteBuyAmount,
            minBaseLadder,
            minQuoteLadder,
            priceMaxPrecision,
          } = Current.Terminal.Validation;
          const fns = {
            calcLadderPrices: (a, b, n, tpP) => {
              const start = a > b ? a : b;
              const stop = a > b ? b : a;
              const linear = (start - stop) / (n - 1);
              const tp = Number(tpP) / 100;
              const tpCalc = side == "buy" ? 1 + tp : 1 - tp;
              const prices = [
                {
                  bp: Number(start).toFixed(priceMaxPrecision),
                  tp: (Number(start) * tpCalc).toFixed(priceMaxPrecision),
                },
              ];
              for (let i = 0; i < n - 2; i++) {
                const p =
                  Number(prices[i == 0 ? 0 : prices.length - 1].bp) -
                  Number(linear);
                prices.push({
                  bp: Number(p).toFixed(priceMaxPrecision),
                  tp: (Number(p) * tpCalc).toFixed(priceMaxPrecision),
                });
              }
              prices.push({
                bp: Number(stop).toFixed(priceMaxPrecision),
                tp: (Number(stop) * tpCalc).toFixed(priceMaxPrecision),
              });
              return prices;
            },
            setMinLadderVolReq: (prices) => {
              const minPrecisionCheck = (minQuoteBuyAmount, price) => {
                let getBaseAmt = setLength(
                  Number(minQuoteBuyAmount) / price,
                  "base",
                  "number"
                );
                while (getBaseAmt * price < minQuoteBuyAmount) {
                  getBaseAmt = setLength(
                    Number(minBaseSize) + getBaseAmt,
                    "base",
                    "number"
                  );
                }
                const quote = setLength(price * getBaseAmt, "quote", "number");
                return { bReq: getBaseAmt, qReq: quote };
              };
              const minReqAmounts = prices.reduce(
                (t, p) => {
                  const { bReq, qReq } = minPrecisionCheck(
                    minQuoteBuyAmount,
                    Number(p.bp)
                  );
                  t.b += bReq;
                  t.q += qReq;
                  return t;
                },
                { b: 0, q: 0 }
              );
              const minQuoteReq = setLength(minReqAmounts.q, "quote", "number");
              const minBaseReq = setLength(minReqAmounts.b, "base", "number");
              Current.Terminal.Validation.minQuoteLadder = minQuoteReq;
              Current.Terminal.Validation.minBaseLadder = minBaseReq;
              setAttr([smartApproxBase], "min", minBaseReq);
              setAttr([smartApproxQuote], "min", minQuoteReq);
            },
            quote: {
              total: (prices, totalVol) => {
                const orderVol = totalVol / Number(smartNumOrders);
                const orders = prices.map((p) => {
                  const { bReq, qReq } = stayBelowQuoteOrder(
                    orderVol,
                    Number(p.bp)
                  );
                  const o = {
                    price: p.bp,
                    bVol: bReq,
                    qVol: qReq,
                    isQError: false,
                    isBError: false,
                    tp: p.tp,
                  };
                  if (qReq < minQuoteBuyAmount) {
                    o.isQError = true;
                  }
                  if (bReq < Number(minBaseSize)) {
                    o.isBError = true;
                  }
                  return o;
                });
                return orders;
              },
              each: (prices, orderVol) => {
                const orders = prices.map((p) => {
                  const { bReq, qReq } = stayBelowQuoteOrder(
                    orderVol,
                    Number(p.bp)
                  );
                  const o = {
                    price: p.bp,
                    bVol: bReq,
                    qVol: qReq,
                    isQError: false,
                    isBError: false,
                    tp: p.tp,
                  };
                  if (qReq < minQuoteBuyAmount) {
                    o.isQError = true;
                  }
                  if (bReq < Number(minBaseSize)) {
                    o.isBError = true;
                  }
                  return o;
                });
                return orders;
              },
            },
            base: {
              total: (prices, totalVol) => {
                const orderVol = totalVol / Number(smartNumOrders);
                const orders = prices.map((p) => {
                  const { bReq, qReq } = stayBelowTotalBase(
                    orderVol,
                    Number(p.bp),
                    totalVol,
                    Number(smartNumOrders)
                  );
                  const o = {
                    price: p.bp,
                    bVol: bReq,
                    qVol: qReq,
                    isQError: false,
                    isBError: false,
                    tp: p.tp,
                  };
                  if (qReq < minQuoteBuyAmount) {
                    o.isQError = true;
                  }
                  if (bReq < Number(minBaseSize)) {
                    o.isBError = true;
                  }
                  return o;
                });
                return orders;
              },
              each: (prices, orderVol) => {
                const orders = prices.map((p) => {
                  const qVol = setLength(
                    Number(orderVol) * Number(p.bp),
                    "quote",
                    "number"
                  );
                  const o = {
                    price: p.bp,
                    bVol: Number(orderVol),
                    qVol,
                    isQError: false,
                    isBError: false,
                    tp: p.tp,
                  };
                  if (qVol < minQuoteBuyAmount) {
                    o.isQError = true;
                  }
                  return o;
                });
                return orders;
              },
            },
            calcApproxTotals: (orders) => {
              const totals = orders.reduce(
                (t, o) => {
                  t.quote += Number(o.qVol);
                  t.base += Number(o.bVol);
                  return t;
                },
                { quote: 0, base: 0 }
              );
              totals.quote = setLength(totals.quote, "quote", "number");
              totals.base = setLength(totals.base, "base", "number");
              return totals;
            },
            convertToLines: (orders) => {
              const { Lines } = TradingviewChart.Html;
              const { Input } = Lines;
              const bpO = [],
                tpO = [];
              orders.forEach((p, i) => {
                const { price, bVol, isQError, isBError, tp } = p;
                const baseLine = {
                  id: 0,
                  price: setLength(price, "quote", "number"),
                  lineType: "innerPrice",
                  where: "ladderPrice",
                  tradeType: "ladder",
                  amt: bVol,
                  whichOrder: "base",
                  isFinished: false,
                };
                if (i == 0) {
                  baseLine.lineType = "outerPrice";
                }
                if (i == orders.length - 1) {
                  baseLine.lineType = "outerPrice";
                }
                if (isQError || isBError) {
                  baseLine.lineType = "isError";
                  baseLine.amt = "Below Min Required";
                }
                bpO.push(Lines.newLine(baseLine));
                const tpLine = {
                  id: 0,
                  price: setLength(tp, "quote", "number"),
                  lineType: "smartTp",
                  where: "ladderPrice",
                  tradeType: "ladder",
                  amt: bVol,
                  whichOrder: "tp",
                  isFinished: false,
                };
                tpO.push(Lines.newLine(tpLine));
              });
              const comb = [...bpO, ...tpO];
              Input.newLines = comb;
            },
          };
          const prices = fns.calcLadderPrices(
            priceA,
            priceB,
            smartNumOrders,
            smartTpCustom
          );
          fns.setMinLadderVolReq(prices);
          const orders = fns[smartFundingSrc][smartFundingType](
            prices,
            smartTotal
          );
          const approxTotals = fns.calcApproxTotals(orders);
          smartApproxBase.value = approxTotals.base;
          smartApproxQuote.value = approxTotals.quote;
          fns.convertToLines(orders);
          Current.Terminal.orders = orders;
        },
        Inputs: {
          selectSmartBuyOrder: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              TradingviewChart.Html.Lines.Input.changeSide();
              Terminal.Wallet.getAvailableQuote();
              Terminal.Form.Smart.Inputs.smartFundingSrc.switch("quote");
            },
            html: () => {
              selectSmartSide.value = "buy";
              smartBuySubmit.setAttribute(
                "class",
                "d-block btn btn-success no-focus"
              );
              smartSellSubmit.setAttribute("class", "d-none");
              selectSmartBuyOrderToggle.setAttribute(
                "class",
                `d-grid gap-0 buy text-success toggle selected`
              );
              selectSmartSellOrderToggle.setAttribute(
                "class",
                `d-grid gap-0 sell text-secondary toggle`
              );
              walletQuote.innerText = Current.Symbol.quote;
            },
          },
          selectSmartSellOrder: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              TradingviewChart.Html.Lines.Input.changeSide();
              Terminal.Wallet.getAvailableBase();
              Terminal.Form.Smart.Inputs.smartFundingSrc.switch("base");
            },
            html: () => {
              selectSmartSide.value = "sell";
              smartSellSubmit.setAttribute(
                "class",
                "d-block btn btn-danger no-focus"
              );
              smartBuySubmit.setAttribute("class", "d-none");
              selectSmartSellOrderToggle.setAttribute(
                "class",
                `d-grid gap-0 sell text-danger toggle selected`
              );
              selectSmartBuyOrderToggle.setAttribute(
                "class",
                `d-grid gap-0 buy text-secondary toggle`
              );
              walletQuote.innerText = Current.Symbol.base;
            },
          },
          smartTradeType: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              const { tradeType } = Terminal.Form.Smart.InputVal();
              const types = {
                single: () => {
                  smartPriceA.required = true;
                  smartPriceA.focus();
                  smartPriceB.value = "";
                  smartPriceB.disabled = true;
                  smartPriceB.required = false;
                  smartFundingSrc.disabled = true;
                  smartNumOrders.disabled = true;
                  smartNumOrders.value = "1";
                  smartTP.disabled = false;
                  smartTP.value = "";
                  smartTpCustom.value = "10";
                  ladder1.disabled = false;
                  smartOrderType.disabled = false;
                  smartFundingType.value = "total";
                  smartFundingType.disabled = true;
                  smartTotal.required = true;
                },
                ladder: () => {
                  smartPriceA.disabled = false;
                  smartPriceA.required = true;
                  smartPriceB.required = true;
                  smartPriceB.disabled = false;
                  smartNumOrders.disabled = false;
                  smartTP.value = "";
                  smartTpCustom.value = "10";
                  smartTP.disabled = true;
                  smartOrderType.value = "limit";
                  smartNumOrders.value = "10";
                  ladder1.disabled = true;
                  smartFundingType.disabled = false;
                  smartOrderType.disabled = true;
                },
              };
              types[tradeType]();
            },
            html: () => {
              Terminal.Form.Util.clear();
              Terminal.Form.Smart.setInputReq();
            },
          },
          smartOrderType: {
            checkConditions: (clear) => {
              const { Smart } = Terminal.Form;
              const { orderType } = Smart.InputVal();
              const { updateHTML } = Smart.Validation;
              const orderTypes = {
                limit: () => {},
                market: () => {},
              };
              orderTypes[orderType]();
            },
            calc: () => {
              const { Smart } = Terminal.Form;
              const { orderType } = Smart.InputVal();
              const { minBaseSize, minQuoteBuyAmount } =
                Current.Terminal.Validation;
              const orderTypes = {
                limit: () => {},
                market: () => {
                  Smart.runCalc("smartTotal");
                },
              };
              Smart.setInputReq();
              orderTypes[orderType]();
            },
            html: () => {
              const { orderType, side } = Terminal.Form.Smart.InputVal();
              const types = {
                limit: () => {
                  smartPriceA.required = true;
                  smartPriceA.disabled = false;
                  smartPriceA.value = "";
                  smartPriceB.disabled = true;
                  smartPriceB.value = "";
                  smartFundingSrc.disabled = false;
                  smartPriceA.focus();
                },
                market: () => {
                  smartPriceA.required = false;
                  smartPriceA.value = "";
                  smartPriceB.value = "";
                  smartPriceA.disabled = true;
                  smartPriceB.disabled = true;
                  if (side == "buy") {
                    smartFundingSrc.value = "quote";
                  } else {
                    smartFundingSrc.value = "base";
                  }
                  smartFundingSrc.disabled = true;
                  smartTotal.focus();
                  const { value } = smartTotal;
                  smartTotal.value = "";
                  smartTotal.value = value;
                },
              };
              types[orderType]();
            },
          },
          smartPriceA: {
            errors: () => {
              return {
                inputId: smartPriceA,
                errorId: smartPriceAError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm input-focus",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { priceMaxPrecision } = Current.Terminal.Validation;
              const { Smart, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { tradeType, orderType, priceA, priceB } = Smart.InputVal();
              const { updateHTML } = Smart.Validation;
              updateHTML("smartPriceA");
              if (clear || !priceA) {
                return;
              }
              const orderTypes = {
                limit: () => {
                  if (!priceA) {
                    updateHTML("smartPriceA", true, "quote", "min");
                  }
                  const dot = convertToUs(priceA).indexOf(".");
                  if (dot > -1) {
                    const split = convertToUs(priceA).split(".");
                    if (split[1].length > priceMaxPrecision) {
                      updateHTML("smartPriceA", true, "quote", "format");
                    }
                  }
                },
                market: () => {},
              };
              const tradeTypes = {
                single: () => {
                  orderTypes[orderType]();
                },
                ladder: () => {
                  orderTypes.limit();
                },
              };
              tradeTypes[tradeType]();
            },
            calc: () => {
              const { Smart, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { priceA, priceB, smartTotal, tradeType, smartFundingSrc } =
                Smart.InputVal();
              const { setLength, stayBelowQuoteOrder } = Terminal.Form.Util;
              const tradeTypes = {
                single: () => {
                  if (!priceA || !smartTotal) {
                    return;
                  }
                  let base, quote;
                  if (smartFundingSrc == "quote") {
                    const { bReq, qReq } = stayBelowQuoteOrder(
                      smartTotal,
                      priceA
                    );
                    quote = qReq;
                    base = bReq;
                  } else {
                    base = setLength(smartTotal, "base", "number");
                    quote = setLength(base * priceA, "quote", "number");
                  }
                  smartApproxQuote.value = convertToUs(quote);
                  smartApproxBase.value = convertToUs(base);
                  const { Lines } = TradingviewChart.Html;
                  const { Input } = Lines;
                  Input.newLines = [
                    Lines.newLine({
                      id: 0,
                      price: priceA,
                      where: "smartPriceA",
                      tradeType: "single",
                      amt: base,
                      whichOrder: "base",
                      isFinished: false,
                    }),
                  ];
                  Smart.runCalc("smartTpCustom");
                },
                ladder: () => {
                  if (!priceA || !priceB) {
                    smartSpread.value = "";
                    return;
                  }
                  Smart.calcLadderOrders();
                  const sprd = (
                    ((Number(priceA) - Number(priceB)) / Number(priceA)) *
                    100
                  ).toFixed(4);
                  smartSpread.value = convertToUs(sprd);
                },
              };
              tradeTypes[tradeType]();
            },
            html: () => {
              Terminal.Form.Smart.lastFocusID = "smartPriceA";
            },
          },
          smartPriceB: {
            errors: () => {
              return {
                inputId: smartPriceB,
                errorId: smartPriceBError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm input-focus",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { priceMaxPrecision } = Current.Terminal.Validation;
              const { Smart, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { tradeType, orderType, priceB } = Smart.InputVal();
              const { updateHTML } = Smart.Validation;
              updateHTML("smartPriceB");
              if (clear || !priceB) {
                return;
              }
              const orderTypes = {
                limit: () => {
                  if (!priceB) {
                    updateHTML("smartPriceB", true, "quote", "min");
                  }
                  const dot = convertToUs(priceB).indexOf(".");
                  if (dot > -1) {
                    const split = convertToUs(priceB).split(".");
                    if (split[1].length > priceMaxPrecision) {
                      updateHTML("smartPriceB", true, "quote", "format");
                    }
                  }
                },
                market: () => {},
              };
              const tradeTypes = {
                single: () => {},
                ladder: () => {
                  orderTypes.limit();
                },
              };
              tradeTypes[tradeType]();
            },
            calc: () => {
              const { Smart, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { tradeType, priceA, priceB } = Smart.InputVal();
              const tradeTypes = {
                single: () => {},
                ladder: () => {
                  if (!priceA || !priceB) {
                    smartSpread.value = "";
                    return;
                  }
                  Smart.calcLadderOrders();
                  const sprd = (
                    ((Number(priceA) - Number(priceB)) / Number(priceA)) *
                    100
                  ).toFixed(4);
                  smartSpread.value = convertToUs(sprd);
                },
              };
              tradeTypes[tradeType]();
            },
            html: () => {
              Terminal.Form.Smart.lastFocusID = "smartPriceB";
            },
          },
          smartNumOrders: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              const { Smart } = Terminal.Form;
              const { tradeType } = Smart.InputVal();
              const tradeTypes = {
                single: () => {},
                ladder: () => {
                  Smart.calcLadderOrders();
                },
              };
              tradeTypes[tradeType]();
            },
          },
          smartTpPreset: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: (event) => {
              const { setLength } = Terminal.Form.Util;
              const { Smart, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { tpShortcut } = event.target.dataset;
              const { side, priceA } = Smart.InputVal();
              if (priceA) {
                if (side == "buy") {
                  smartTpCustom.value = convertToUs(Number(tpShortcut));
                } else {
                  smartTpCustom.value = convertToUs(Number(-tpShortcut));
                }
              }
              Smart.runCalc("smartTpCustom");
            },
          },
          smartTpCustom: {
            errors: () => {
              return {
                inputId: smartTpCustom,
                errorId: smartTpCustomError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm input-focus",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Min > 0.5`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Min > 0.5`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Min > 0.5`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { Smart } = Terminal.Form;
              const { smartTpCustom } = Smart.InputVal();
              const { updateHTML } = Smart.Validation;
              updateHTML("smartTpCustom");
              if (clear) {
                return;
              }
              if (!smartTpCustom || smartTpCustom < 0.5) {
                updateHTML("smartTpCustom", true, "quote", "min");
              }
            },
            calc: () => {
              //const { setLength } = Terminal.Form.Util;
              const { Smart, Util } = Terminal.Form;
              const { setLength, convertToUs } = Util;
              const { tradeType, side, smartTpCustom, priceA } =
                Smart.InputVal();
              if (priceA) {
                if (tradeType == "single") {
                  if (side == "buy") {
                    smartTP.value = convertToUs(
                      setLength(
                        priceA * (1 + smartTpCustom / 100),
                        "quote",
                        "number"
                      )
                    );
                  } else {
                    smartTP.value = convertToUs(
                      setLength(
                        priceA * (1 - smartTpCustom / 100),
                        "quote",
                        "number"
                      )
                    );
                  }
                  Smart.runCalc("smartTP");
                } else {
                  Smart.calcLadderOrders();
                }
              }
            },
          },
          smartTP: {
            errors: () => {
              return {
                inputId: smartTP,
                errorId: smartTPError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm input-focus",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Must be greater than 0`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { priceMaxPrecision } = Current.Terminal.Validation;
              const { Smart, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { tradeType, orderType, smartTP } = Smart.InputVal();
              const { updateHTML } = Smart.Validation;
              updateHTML("smartTP");
              if (clear || !smartTP) {
                return;
              }
              const orderTypes = {
                limit: () => {
                  if (!smartTP) {
                    updateHTML("smartTP", true, "quote", "min");
                  }
                  const dot = convertToUs(smartTP).indexOf(".");
                  if (dot > -1) {
                    const split = convertToUs(smartTP).split(".");
                    if (split[1].length > priceMaxPrecision) {
                      updateHTML("smartTP", true, "quote", "format");
                    }
                  }
                },
                market: () => {},
              };
              const tradeTypes = {
                single: () => {
                  orderTypes[orderType]();
                },
                ladder: () => {},
              };
              tradeTypes[tradeType]();
            },
            calc: () => {
              const { Smart } = Terminal.Form;
              const { smartApproxBase, smartTP } = Smart.InputVal();
              const { Lines } = TradingviewChart.Html;
              const { Input } = Lines;
              const base = Input.newLines.filter((f) => {
                return f.whichOrder == "base";
              });
              const add = Lines.newLine({
                id: 0,
                price: smartTP,
                where: "smartTP",
                tradeType: "single",
                amt: smartApproxBase,
                whichOrder: "tp",
                isFinished: false,
              });
              if (!base[0]) {
                Input.newLines = [add];
              } else {
                if (Input.newLines.length == 2) {
                  base.push(add);
                  Input.newLines = base;
                } else {
                  Input.newLines.push(add);
                }
              }
            },
            html: () => {
              Terminal.Form.Smart.lastFocusID = "smartTP";
            },
          },
          smartFundingType: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              const { Smart } = Terminal.Form;
              const { tradeType } = Smart.InputVal();
              const tradeTypes = {
                single: () => {},
                ladder: () => {
                  Smart.calcLadderOrders();
                },
              };
              tradeTypes[tradeType]();
            },
          },
          smartFundingSrc: {
            checkConditions: (clear) => {},
            html: () => {
              Terminal.Form.Smart.setInputReq();
            },
            switch: (which) => {
              smartFundingSrc.value = which;
              Terminal.Form.Smart.setInputReq();
            },
            calc: () => {
              const { Smart } = Terminal.Form;
              const {
                tradeType,
                orderType,
                smartFundingSrc,
                smartApproxQuote,
                smartApproxBase,
              } = Smart.InputVal();
              const { minBaseSize, minQuoteBuyAmount } =
                Current.Terminal.Validation;
              const tradeTypes = {
                single: () => {
                  const orderTypes = {
                    limit: () => {
                      if (smartFundingSrc == "quote") {
                        smartTotal.value = smartApproxQuote;
                      } else {
                        smartTotal.value = smartApproxBase;
                      }
                    },
                    market: () => {},
                  };
                  orderTypes[orderType]();
                },
                ladder: () => {
                  if (smartFundingSrc == "quote") {
                    smartTotal.value = smartApproxQuote;
                  } else {
                    smartTotal.value = smartApproxBase;
                  }
                  Smart.calcLadderOrders();
                },
              };
              tradeTypes[tradeType]();
              smartTotal.focus();
            },
          },
          smartCustomPreset: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: (event) => {
              const { category } = Current.Terminal;
              const { Smart, Util } = Terminal.Form;
              const { setLength, convertToUs } = Util;
              const { side, smartFundingSrc } = Smart.InputVal();
              const { volShortcut } = event.target.dataset;
              const { wallet } = Current.Terminal;
              if (category !== "smart") {
                return;
              }
              if (side == "buy") {
                if (smartFundingSrc == "quote" && wallet.buy > 0) {
                  smartTotal.value = convertToUs(
                    setLength(
                      Number(volShortcut) * wallet.buy,
                      "quote",
                      "number"
                    )
                  );
                  Smart.runCalc("smartTotal");
                }
              } else {
                if (smartFundingSrc == "base" && wallet.sell > 0) {
                  smartTotal.value = convertToUs(
                    setLength(
                      Number(volShortcut) * wallet.sell,
                      "base",
                      "number"
                    )
                  );
                  Smart.runCalc("smartTotal");
                }
              }
            },
          },
          smartVolCustom: {
            errors: () => {},
            checkConditions: (clear) => {},
            calc: () => {
              const { Smart, Util } = Terminal.Form;
              const { setLength, convertToUs } = Util;
              const { side, smartFundingSrc, smartVolCustom } =
                Smart.InputVal();
              const { wallet } = Current.Terminal;
              if (side == "buy") {
                if (smartFundingSrc == "quote" && smartVolCustom > 0) {
                  smartTotal.value = convertToUs(
                    setLength(
                      (smartVolCustom / 100) * wallet.buy,
                      "quote",
                      "number"
                    )
                  );
                  Smart.runCalc("smartTotal");
                }
              } else {
                if (smartFundingSrc == "base" && smartVolCustom > 0) {
                  smartTotal.value = convertToUs(
                    setLength(
                      (smartVolCustom / 100) * wallet.sell,
                      "base",
                      "number"
                    )
                  );
                  Smart.runCalc("smartTotal");
                }
              }
            },
          },
          smartTotal: {
            errors: () => {
              const { Smart } = Terminal.Form;
              const { smartApproxBase, smartApproxQuote } = Smart.InputVal();
              return {
                inputId: smartTotal,
                errorId: smartTotalError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm input-focus",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Min Quote Size: ${Current.Terminal.Validation.minQuoteBuyAmount}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                      base: {
                        min: `Min Base Size: ${Current.Terminal.Validation.minBaseSize}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.minBaseSize}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Should be ~: ${
                          Current.Terminal.Validation.minQuoteLadder *
                          (1 + 0.034)
                        }`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                      base: {
                        min: `Min Base Size: ${
                          Current.Terminal.Validation.minBaseLadder *
                          (1 + 0.034)
                        }`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.minBaseSize}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Min Quote Size: ${Current.Terminal.Validation.minQuoteBuyAmount}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.precision}`,
                      },
                      base: {
                        min: `Min Base Size: ${Current.Terminal.Validation.minBaseSize}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${Current.Terminal.Validation.minBaseSize}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { Smart, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const { updateHTML } = Smart.Validation;
              const {
                priceMaxPrecision,
                minQuoteBuyAmount,
                minQuoteLadder,
                minBaseSize,
                minBaseLadder,
              } = Current.Terminal.Validation;
              const { wallet } = Current.Terminal;
              const {
                tradeType,
                orderType,
                smartFundingType,
                smartFundingSrc,
                smartTotal,
              } = Smart.InputVal();
              updateHTML("smartTotal");
              if (clear || !smartTotal) {
                return;
              }
              const checks = {
                min: () => {
                  const opts = {
                    single: {
                      total: {
                        quote: Number(minQuoteBuyAmount),
                        base: Number(minBaseSize),
                      },
                    },
                    ladder: {
                      total: {
                        quote: minQuoteLadder,
                        base: minBaseLadder,
                      },
                      each: {
                        quote: Number(minQuoteBuyAmount),
                        base: Number(minBaseSize),
                      },
                    },
                  };
                  const minAmt =
                    opts[tradeType][smartFundingType][smartFundingSrc];
                  if (Number(smartTotal) < minAmt) {
                    updateHTML("smartTotal", true, smartFundingSrc, "min");
                  }
                },
                decimal: () => {
                  let precision;
                  if (smartFundingSrc == "quote") {
                    precision = priceMaxPrecision;
                  } else {
                    if (minBaseSize.includes(".")) {
                      precision = minBaseSize.split(".")[1].length;
                    } else {
                      precision = minBaseSize;
                    }
                  }
                  const dot = convertToUs(smartTotal).indexOf(".");
                  if (dot > -1) {
                    const split = convertToUs(smartTotal).split(".");
                    if (split[1].length > precision) {
                      updateHTML("smartTotal", true, smartFundingSrc, "format");
                    }
                  }
                },
              };
              checks.decimal();
              checks.min();
            },
            calc: () => {
              const { Smart, Util } = Terminal.Form;
              const { convertToUs } = Util;
              const {
                tradeType,
                orderType,
                side,
                priceA,
                smartFundingSrc,
                smartTotal,
              } = Smart.InputVal();
              const tradeTypes = {
                single: () => {
                  const orderTypes = {
                    limit: () => {
                      if (!smartTotal) {
                        smartApproxBase.value = 0;
                        smartApproxQuote.value = 0;
                      }
                      Smart.runCalc("smartPriceA");
                    },
                    market: () => {
                      if (side == "buy") {
                        smartApproxBase.value = 0;
                        smartApproxQuote.value = convertToUs(smartTotal);
                      } else {
                        smartApproxBase.value = convertToUs(smartTotal);
                        smartApproxQuote.value = 0;
                      }
                    },
                  };
                  orderTypes[orderType]();
                },
                ladder: () => {
                  Smart.calcLadderOrders();
                },
              };
              tradeTypes[tradeType]();
            },
          },
          smartApproxBase: {
            errors: () => {
              const { setLength } = Terminal.Form.Util;
              const smartApproxB =
                Terminal.Form.Smart.InputVal().smartApproxBase;
              const {
                minQuoteBuyAmount,
                minBaseSize,
                minQuoteLadder,
                minBaseLadder,
                precision,
                step,
              } = Current.Terminal.Validation;
              const diff = (source, target) => {
                return setLength(Number(source) - Number(target), "base");
              };
              return {
                inputId: smartApproxBase,
                errorId: smartApproxBaseError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Min Req: ${minQuoteBuyAmount} | Inc By: ${diff(
                          minQuoteBuyAmount,
                          smartApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseSize} | Inc By: ${diff(
                          minBaseSize,
                          smartApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                        mod: `Must end with step: ${step}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Min Req: ${minQuoteLadder} | Inc By: ${diff(
                          minQuoteLadder,
                          smartApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseLadder} | Inc By: ${diff(
                          minBaseLadder,
                          smartApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                        mod: `Must end with step: ${step}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Min Req: ${minQuoteBuyAmount} | Inc By: ${diff(
                          minQuoteBuyAmount,
                          smartApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseSize} | Inc By: ${diff(
                          minBaseSize,
                          smartApproxB
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                        mod: `Must end with step: ${step}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { minBaseSize, minBaseLadder, step } =
                Current.Terminal.Validation;
              const { wallet } = Current.Terminal;
              const { Smart } = Terminal.Form;
              const { updateHTML } = Smart.Validation;
              const {
                side,
                tradeType,
                orderType,
                smartApproxBase,
                smartFundingType,
              } = Smart.InputVal();
              updateHTML("smartApproxBase");
              if (clear || !smartApproxBase) {
                return;
              }
              const checks = {
                min: () => {
                  const opts = {
                    single: {
                      total: {
                        base: Number(minBaseSize),
                      },
                    },
                    ladder: {
                      total: {
                        base: minBaseLadder,
                      },
                      each: {
                        base: Number(minBaseSize),
                      },
                    },
                  };
                  const minAmt = opts[tradeType][smartFundingType].base;
                  if (
                    orderType == "limit" &&
                    Number(smartApproxBase) < minAmt
                  ) {
                    updateHTML("smartApproxBase", true, "base", "min");
                  }
                },
                max: () => {
                  if (smartApproxBase > wallet.sell && side == "sell") {
                    updateHTML("smartApproxBase", true, "quote", "max");
                  }
                },
                mod: () => {
                  if (smartApproxBase % Number(step)) {
                    updateHTML("smartApproxBase", true, "base", "mod");
                  }
                },
              };
              checks.min();
              checks.max();
              //checks.mod();
            },
            html: (event) => {
              event.preventDefault();
              event.stopPropagation();
              smartApproxBase.focus();
              smartApproxBase.select();
              document.execCommand("copy");
              return false;
            },
            calc: () => {},
          },
          smartApproxQuote: {
            errors: () => {
              const { setLength } = Terminal.Form.Util;
              const smartApproxQ =
                Terminal.Form.Smart.InputVal().smartApproxQuote;
              const {
                minQuoteBuyAmount,
                minBaseSize,
                minQuoteLadder,
                minBaseLadder,
                precision,
              } = Current.Terminal.Validation;
              const diff = (source, target) => {
                return setLength(Number(source) - Number(target), "quote");
              };
              return {
                inputId: smartApproxQuote,
                errorId: smartApproxQuoteError,
                class: {
                  error: "form-control form-control-sm is-invalid",
                  resolved: "form-control form-control-sm",
                },
                msg: {
                  single: {
                    total: {
                      quote: {
                        min: `Min Req: ${minQuoteBuyAmount} | Inc By: ${diff(
                          minQuoteBuyAmount,
                          smartApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseSize} | Inc By: ${diff(
                          minBaseSize,
                          smartApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                      },
                    },
                  },
                  ladder: {
                    total: {
                      quote: {
                        min: `Min Req: ${minQuoteLadder} | Inc By: ${diff(
                          minQuoteLadder,
                          smartApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseLadder} | Inc By: ${diff(
                          minBaseLadder,
                          smartApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                      },
                    },
                    each: {
                      quote: {
                        min: `Min Req: ${minQuoteBuyAmount} | Inc By: ${diff(
                          minQuoteBuyAmount,
                          smartApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${precision}`,
                      },
                      base: {
                        min: `Min Req: ${minBaseSize} | Inc By: ${diff(
                          minBaseSize,
                          smartApproxQ
                        )}`,
                        max: `Not Enough Funds`,
                        format: `Please use format: ${minBaseSize}`,
                      },
                    },
                  },
                },
              };
            },
            checkConditions: (clear) => {
              const { minQuoteBuyAmount, minQuoteLadder } =
                Current.Terminal.Validation;
              const { wallet } = Current.Terminal;
              const { Smart } = Terminal.Form;
              const { updateHTML } = Smart.Validation;
              const {
                side,
                tradeType,
                orderType,
                smartApproxQuote,
                smartFundingType,
              } = Smart.InputVal();
              updateHTML("smartApproxQuote");
              if (clear || !smartApproxQuote) {
                return;
              }
              const checks = {
                min: () => {
                  const opts = {
                    single: {
                      total: {
                        quote: Number(minQuoteBuyAmount),
                      },
                    },
                    ladder: {
                      total: {
                        quote: minQuoteLadder,
                      },
                      each: {
                        quote: Number(minQuoteBuyAmount),
                      },
                    },
                  };
                  const minAmt = opts[tradeType][smartFundingType].quote;
                  if (
                    orderType == "limit" &&
                    Number(smartApproxQuote) < minAmt
                  ) {
                    updateHTML("smartApproxQuote", true, "quote", "min");
                  }
                },
                max: () => {
                  if (smartApproxQuote > wallet.buy && side == "buy") {
                    updateHTML("smartApproxQuote", true, "quote", "max");
                  }
                },
              };
              checks.min();
              checks.max();
            },
            html: (event) => {
              event.preventDefault();
              event.stopPropagation();
              smartApproxQuote.focus();
              smartApproxQuote.select();
              document.execCommand("copy");
              return false;
            },
            calc: () => {},
          },
        },
        Validation: {
          test: (clear = false) => {
            const { Inputs } = Terminal.Form.Smart;
            for (const key in Inputs) {
              if (Object.hasOwnProperty.call(Inputs, key)) {
                if ("calc" in Inputs[key]) {
                  Inputs[key].checkConditions(clear);
                }
              }
            }
          },
          updateHTML: (where, isError = false, smartFundingSrc, text) => {
            const { Smart } = Terminal.Form;
            const { tradeType, smartFundingType } = Smart.InputVal();
            const e = Smart.Inputs[where].errors();
            if (!isError) {
              e.inputId.setAttribute("class", e.class.resolved);
              return;
            }
            e.inputId.setAttribute("class", e.class.error);
            e.errorId.innerText =
              e.msg[tradeType][smartFundingType][smartFundingSrc][text];
          },
        },
        submitSmartOrder: (event) => {
          event.preventDefault();
          const form = event.target;
          event.target.reportValidity();
          if (event.target.checkValidity()) {
            let text, btn;
            if (selectSmartSide.value == "buy") {
              text = "Buy";
              btn = "smartBuySubmit";
            } else {
              text = "Sell";
              btn = "smartSellSubmit";
            }
            const serialized = $(smartForm).serializeArray();
            serialized.push({
              name: "orders",
              value: Current.Terminal.orders,
            });
            const readyToSend = serialized.reduce((t, el) => {
              t[el.name] = el.value;
              return t;
            }, {});
            Utility.Page.loading(btn, true, "center", "small", true);
            Utility.Server.run()
              .withSuccessHandler((result) => {
                Utility.Page.loading(btn, false, null, null, null, text);
                if (result) {
                  Orders.update();
                  Terminal.Wallet.getAvailable();
                  TradingviewChart.Html.Lines.Input.newLines = [];
                  TradingviewChart.Html.Lines.Input.create();
                  TradingviewChart.Html.Markers.create();
                }
              })
              .withFailureHandler((err) => {
                Utility.Page.loading(btn, false, null, null, null, text);
                TradeUtility.Page.errResponses(err);
                Orders.update();
                Terminal.Wallet.getAvailable();
                TradingviewChart.Html.Lines.Input.newLines = [];
                TradingviewChart.Html.Lines.Input.create();
              })
              .submitSmartOrder(readyToSend);
          } else {
            Terminal.Form.Smart.Validation.test();
            event.stopPropagation();
          }
        },
      },
    },
    Wallet: {
      getAvailable: () => {
        const { category } = Current.Terminal;
        if (category == "simple") {
          const { Simple } = Terminal.Form;
          const { side } = Simple.InputVal();
          if (side == "buy") {
            Terminal.Wallet.getAvailableQuote();
          } else {
            Terminal.Wallet.getAvailableBase();
          }
        }
        if (category == "smart") {
          const { Smart } = Terminal.Form;
          const { side } = Smart.InputVal();
          if (side == "buy") {
            Terminal.Wallet.getAvailableQuote();
          } else {
            Terminal.Wallet.getAvailableBase();
          }
        }
      },
      getAvailableQuote: () => {
        const { quote } = Current.Symbol;
        const { setLength } = Terminal.Form.Util;
        Utility.Page.loading("currentWalletAmt", true, "center", "small", true);
        Utility.Server.run()
          .withSuccessHandler((q) => {
            Utility.Page.loading("currentWalletAmt", false);
            Current.Terminal.wallet.buy = setLength(q, "quote");
            currentWalletAmt.innerText = setLength(q, "quote");
            simpleApproxQuote.setAttribute("max", setLength(q, "quote"));
            simpleApproxBase.setAttribute("max", Infinity);
            smartApproxQuote.setAttribute("max", setLength(q, "quote"));
            smartApproxBase.setAttribute("max", Infinity);
          })
          .withFailureHandler((err) => {
            Utility.Page.loading("currentWalletAmt", false);
            Current.Terminal.wallet.buy = 0;
            currentWalletAmt.innerText = 0;
            simpleApproxQuote.setAttribute("max", 0);
            simpleApproxBase.setAttribute("max", Infinity);
            smartApproxQuote.setAttribute("max", 0);
            smartApproxBase.setAttribute("max", Infinity);
            TradeUtility.Page.errResponses(err);
          })
          .getAvailable(quote);
      },
      getAvailableBase: () => {
        const { base } = Current.Symbol;
        const { setLength } = Terminal.Form.Util;
        Utility.Page.loading("currentWalletAmt", true, "center", "small", true);
        Utility.Server.run()
          .withSuccessHandler((q) => {
            Utility.Page.loading("currentWalletAmt", false);
            Current.Terminal.wallet.sell = setLength(q, "base");
            currentWalletAmt.innerText = setLength(q, "base");
            simpleApproxBase.setAttribute("max", setLength(q, "base"));
            simpleApproxQuote.setAttribute("max", Infinity);
            smartApproxBase.setAttribute("max", setLength(q, "base"));
            smartApproxQuote.setAttribute("max", Infinity);
          })
          .withFailureHandler((err) => {
            Utility.Page.loading("currentWalletAmt", false);
            Current.Terminal.wallet.sell = 0;
            currentWalletAmt.innerText = 0;
            simpleApproxBase.setAttribute("max", 0);
            simpleApproxQuote.setAttribute("max", Infinity);
            smartApproxBase.setAttribute("max", 0);
            smartApproxQuote.setAttribute("max", Infinity);
            TradeUtility.Page.errResponses(err);
          })
          .getAvailable(base);
      },
    },
  };

  // Market Trade History ===========================
  // cTradeHistory
  const tradeHistoryContainer = document.getElementById(
    "tradeHistoryContainer"
  );
  const tradeHistoryTable = document.getElementById("tradeHistoryTable");
  const TradeHistory = {
    init: () => {
      tradeHistoryTable.innerHTML = "";
      Utility.Page.loading("tradeHistoryLoading", true);
    },
    WS: {
      update: (msg) => {
        if (msg.length == 50) {
          Utility.Page.loading("tradeHistoryLoading", false);
          const mostRecent = msg[0];
          Current.History.lastTrade = mostRecent;
          msg.sort((a, b) => {
            if (a.s_t == b.s_t) {
              if (a.side == "buy" && b.side == "buy") {
                return b.price - a.price;
              }
              if (a.side == "sell" && b.side == "sell") {
                return a.price - b.price;
              }
            } else {
              return b.s_t - a.s_t;
            }
          });
          TradeHistory.Html.add(msg);
        } else {
          const time = Current.History.lastTrade.s_t * 1000;
          const newMarketTrades = msg.filter((t) => {
            return t.s_t * 1000 > time;
          });
          TradeHistory.Html.update(newMarketTrades);
        }
      },
    },
    User: {
      onClick: (event) => {
        const val = event.target.innerText;
        const { category } = Current.Terminal;
        const { price, qty } = event.target.dataset;
        const categories = {
          simple: () => {
            const { Simple } = Terminal.Form;
            const { lastFocusID } = Simple;
            const { tradeType, orderType } = Simple.InputVal();
            const types = {
              single: {
                limit: () => {
                  if (price === "true") {
                    simplePriceA.value = val;
                    Simple.runCalc("simplePriceA");
                    simplePriceA.focus();
                  }
                  if (qty === "true") {
                    Simple.Inputs.simpleFundingSrc.switch("base");
                    simpleTotal.value = val;
                    Simple.runCalc("simpleTotal");
                    simpleTotal.focus();
                  }
                },
                market: () => {
                  if (qty === "true") {
                    simpleTotal.value = val;
                    Simple.runCalc("simpleTotal");
                    simpleTotal.focus();
                  }
                },
              },
              ladder: {
                limit: () => {
                  if (price === "true") {
                    const selectID = document.getElementById(lastFocusID);
                    selectID.value = val;
                    Simple.runCalc(lastFocusID);
                    selectID.focus();
                  }
                  if (qty === "true") {
                    Simple.Inputs.simpleFundingSrc.switch("base");
                    simpleTotal.value = val;
                    Simple.runCalc("simpleTotal");
                    simpleTotal.focus();
                  }
                },
              },
            };
            types[tradeType][orderType]();
          },
          smart: () => {
            const { Smart } = Terminal.Form;
            const { lastFocusID } = Smart;
            const { tradeType, orderType } = Smart.InputVal();
            const types = {
              single: {
                limit: () => {
                  if (price === "true") {
                    smartPriceA.value = val;
                    Smart.runCalc("smartPriceA");
                    smartPriceA.focus();
                  }
                  if (qty === "true") {
                    Smart.Inputs.smartFundingSrc.switch("base");
                    smartTotal.value = val;
                    Smart.runCalc("smartTotal");
                    smartTotal.focus();
                  }
                },
                market: () => {},
              },
              ladder: {
                limit: () => {
                  if (price === "true") {
                    const selectID = document.getElementById(lastFocusID);
                    selectID.value = val;
                    Smart.runCalc(lastFocusID);
                    selectID.focus();
                  }
                  if (qty === "true") {
                    Smart.Inputs.smartFundingSrc.switch("base");
                    smartTotal.value = val;
                    Smart.runCalc("smartTotal");
                    smartTotal.focus();
                  }
                },
              },
            };
            types[tradeType][orderType]();
          },
        };
        categories[category]();
      },
    },
    Html: {
      update: (toAdd) => {
        const { setLength } = Terminal.Form.Util;
        const htmlRows = toAdd.map((r) => {
          const time = r.s_t * 1000;
          const tt = new Date(time).toLocaleDateString();
          const order_time = new Date(time).toLocaleTimeString();
          const color = r.side == "buy" ? "text-success" : "text-danger";
          const row = document.createElement("tr");
          const template = `
          <td scope="row" class="col-4 ${color} text-start">
            <span
              class="d-inline-block text-truncate-left bitUL"
              data-price="true"
              data-qty="false"
              data-bs-toggle="tooltip"
              data-bs-placement="bottom"
              title="${r.price}"
              >${r.price}</span
            >
          </td>
          <td class="col-4 text-light">
            <span
              class="d-inline-block text-truncate-right bitUL"
              data-price="false"
              data-qty="true"
              data-bs-toggle="tooltip"
              data-bs-placement="bottom"
              title="${r.size}"
              >${r.size}</span
            >
          </td>
          <td class="col-4 text-secondary text-truncate-right text-end">
            <span
              data-price="false"
              data-qty="false"
              data-bs-toggle="tooltip"
              data-bs-placement="bottom"
              title="${tt}"
            >
              ${order_time}
            </span>
          </td>
          `;
          row.innerHTML = template;
          return row;
        });
        htmlRows.forEach((r) => {
          const tLength = tradeHistoryTable.rows.length;
          if (tLength > 0) {
            tradeHistoryTable.deleteRow(tLength - 1);
          }
          tradeHistoryTable.prepend(r);
        });
        if (toAdd.length) {
          Current.History.lastTrade = toAdd[0];
          OrderBook.Html.updateSpreadLastTrade(toAdd[0]);
          const oldBVol = statsBVol.innerText;
          statsBVol.innerText = (
            Number(oldBVol) + Number(toAdd[0].size)
          ).toFixed(2);
        }
      },
      add: (marketTrades) => {
        const htmlString = marketTrades.reduce((t, el) => {
          const time = el.s_t * 1000;
          const tt = new Date(time).toLocaleDateString();
          const order_time = new Date(time).toLocaleTimeString();
          const color = el.side == "buy" ? "text-success" : "text-danger";
          const template = `
                <tr>
                  <td scope="row" class="col-4 ${color} text-start">
                    <span
                      class="d-inline-block text-truncate-left bitUL"
                      data-price="true"
                      data-qty="false"
                      data-bs-toggle="tooltip"
                      data-bs-placement="bottom"
                      title="${el.price}"
                      >${el.price}</span
                    >
                  </td>
                  <td class="col-4 text-light">
                    <span
                      class="d-inline-block text-truncate-right bitUL"
                      data-price="false"
                      data-qty="true"
                      data-bs-toggle="tooltip"
                      data-bs-placement="bottom"
                      title="${el.size}"
                      >${el.size}</span
                    >
                  </td>
                  <td class="col-4 text-secondary text-truncate-right text-end">
                    <span
                      data-price="false"
                      data-qty="false"
                      data-bs-toggle="tooltip"
                      data-bs-placement="bottom"
                      title="${tt}"
                    >
                      ${order_time}
                    </span>
                  </td>
                </tr>`;
          return (t += template);
        }, "");
        tradeHistoryTable.innerHTML = htmlString;
        OrderBook.Html.updateSpreadLastTrade(marketTrades[0]);
      },
    },
  };

  // Order Book ===========================
  // cOrderbook
  const bidOrderBookTable = document.getElementById("bidOrderBookTable");
  const askOrderBookTable = document.getElementById("askOrderBookTable");
  const orderBookSpread = document.getElementById("orderBookSpread");
  const orderBookLast = document.getElementById("orderBookLast");
  const OrderBook = {
    init: () => {
      if (!Current.OrderBook.created) {
        OrderBook.Html.create();
      }
      Utility.Page.loading("orderBookAskLoading", true);
      Utility.Page.loading("orderBookBidLoading", true);
    },
    WS: {
      update: (msg) => {
        if (Current.OrderBook.created) {
          const inc = msg[0];
          const bid = inc.bids;
          const ask = inc.asks.reverse();
          OrderBook.Html.updateBids(bid);
          OrderBook.Html.updateAsks(ask);
          OrderBook.Html.updateSpread(bid[0][0], ask[49][0]);
        }
      },
    },
    User: {
      onClick: (event) => {
        const { category } = Current.Terminal;
        const { price, qty, total } = event.target.dataset;
        const val = event.target.innerText;
        const categories = {
          simple: () => {
            const { Simple } = Terminal.Form;
            const { lastFocusID } = Simple;
            const { tradeType, orderType } = Simple.InputVal();
            const types = {
              single: {
                limit: () => {
                  if (price === "true") {
                    simplePriceA.value = val;
                    Simple.runCalc("simplePriceA");
                    simplePriceA.focus();
                  }
                  if (qty === "true") {
                    Simple.Inputs.simpleFundingSrc.switch("base");
                    simpleTotal.value = val;
                    Simple.runCalc("simpleTotal");
                    simpleTotal.focus();
                  }
                  if (total === "true") {
                    Simple.Inputs.simpleFundingSrc.switch("quote");
                    simpleTotal.value = val;
                    Simple.runCalc("simpleTotal");
                    simpleTotal.focus();
                  }
                },
                market: () => {
                  if (qty === "true") {
                    simpleTotal.value = val;
                    Simple.runCalc("simpleTotal");
                    simpleTotal.focus();
                  }
                },
              },
              ladder: {
                limit: () => {
                  if (price === "true") {
                    const selectID = document.getElementById(lastFocusID);
                    selectID.value = val;
                    Simple.runCalc(lastFocusID);
                    selectID.focus();
                  }
                  if (qty === "true") {
                    Simple.Inputs.simpleFundingSrc.switch("base");
                    simpleTotal.value = val;
                    Simple.runCalc("simpleTotal");
                    simpleTotal.focus();
                  }
                  if (total === "true") {
                    Simple.Inputs.simpleFundingSrc.switch("quote");
                    simpleTotal.value = val;
                    Simple.runCalc("simpleTotal");
                    simpleTotal.focus();
                  }
                },
              },
            };
            types[tradeType][orderType]();
          },
          smart: () => {
            const { Smart } = Terminal.Form;
            const { lastFocusID } = Smart;
            const { tradeType, orderType } = Smart.InputVal();
            const types = {
              single: {
                limit: () => {
                  if (price === "true") {
                    smartPriceA.value = val;
                    Smart.runCalc("smartPriceA");
                    smartPriceA.focus();
                  }
                  if (qty === "true") {
                    Smart.Inputs.smartFundingSrc.switch("base");
                    smartTotal.value = val;
                    Smart.runCalc("smartTotal");
                    smartTotal.focus();
                  }
                  if (total === "true") {
                    Smart.Inputs.smartFundingSrc.switch("quote");
                    smartTotal.value = val;
                    Smart.runCalc("smartTotal");
                    smartTotal.focus();
                  }
                },
                market: () => {
                  if (qty === "true") {
                    smartTotal.value = val;
                    Smart.runCalc("smartTotal");
                    smartTotal.focus();
                  }
                },
              },
              ladder: {
                limit: () => {
                  if (price === "true") {
                    const selectID = document.getElementById(lastFocusID);
                    selectID.value = val;
                    Smart.runCalc(lastFocusID);
                    selectID.focus();
                  }
                  if (qty === "true") {
                    Smart.Inputs.smartFundingSrc.switch("base");
                    smartTotal.value = val;
                    Smart.runCalc("smartTotal");
                    smartTotal.focus();
                  }
                  if (total === "true") {
                    Smart.Inputs.smartFundingSrc.switch("quote");
                    smartTotal.value = val;
                    Smart.runCalc("smartTotal");
                    smartTotal.focus();
                  }
                },
              },
            };
            types[tradeType][orderType]();
          },
        };
        categories[category]();
      },
    },
    Html: {
      create: () => {
        let bTemplate = "",
          aTemplate = "";
        for (let index = 0; index < 50; index++) {
          aTemplate += `
            <tr>
              <td scope="row" class="col-4 text-danger text-start">
                <span
                  class="d-inline-block text-truncate-left bitUL"
                  id="ob_a_p_${index}"
                  data-price="true"
                  data-qty="false"
                  data-total="false"
                  data-bs-toggle="tooltip"
                  data-bs-placement="bottom"
                  title="0"
                  >0</span
                >
              </td>
              <td class="col-4 text-light">
                <span
                  class="d-inline-block text-truncate-right bitUL"
                  id="ob_a_q_${index}"
                  data-price="false"
                  data-qty="true"
                  data-total="false"
                  data-bs-toggle="tooltip"
                  data-bs-placement="bottom"
                  title="0"
                  >0</span
                >
              </td>
              <td class="col-4 text-light text-end">
                <span
                  class="d-inline-block text-truncate-right bitUL"
                  id="ob_a_t_${index}"
                  data-price="false"
                  data-qty="false"
                  data-total="true"
                  data-bs-toggle="tooltip"
                  data-bs-placement="bottom"
                  title="0"
                >
                  0
                </span>
              </td>
            </tr>
            `;
          bTemplate += `
            <tr>
              <td scope="row" class="col-4 text-success text-start">
                <span
                  class="d-inline-block text-truncate-left bitUL"
                  id="ob_b_p_${index}"
                  data-price="true"
                  data-qty="false"
                  data-total="false"
                  data-bs-toggle="tooltip"
                  data-bs-placement="bottom"
                  title="0"
                  >0</span
                >
              </td>
              <td class="col-4 text-light">
                <span
                  class="d-inline-block text-truncate-right bitUL"
                  id="ob_b_q_${index}"
                  data-price="false"
                  data-qty="true"
                  data-total="false"
                  data-bs-toggle="tooltip"
                  data-bs-placement="bottom"
                  title="0"
                  >0</span
                >
              </td>
              <td class="col-4 text-light text-end">
                <span
                  class="d-inline-block text-truncate-right bitUL"
                  id="ob_b_t_${index}"
                  data-price="false"
                  data-qty="false"
                  data-total="true"
                  data-bs-toggle="tooltip"
                  data-bs-placement="bottom"
                  title="0"
                >
                  0
                </span>
              </td>
            </tr>
            `;
          bidOrderBookTable.innerHTML = bTemplate;
          askOrderBookTable.innerHTML = aTemplate;
          Current.OrderBook.created = true;
        }
      },
      updateBids: async (bids) => {
        const { setLength } = Terminal.Form.Util;
        bids.forEach((el, i) => {
          const price = el[0];
          const qty = el[1];
          const total = setLength(Number(price) * Number(qty), "quote");
          const pId = document.getElementById(`ob_b_p_${i}`);
          const qId = document.getElementById(`ob_b_q_${i}`);
          const tId = document.getElementById(`ob_b_t_${i}`);
          pId.innerText = price;
          pId.setAttribute("title", price);
          qId.innerText = qty;
          qId.setAttribute("title", qty);
          tId.innerText = total;
          tId.setAttribute("title", total);
        });
      },
      updateAsks: async (asks) => {
        const { setLength } = Terminal.Form.Util;
        asks.forEach((el, i) => {
          const price = el[0];
          const qty = el[1];
          const total = setLength(Number(price) * Number(qty), "quote");
          const pId = document.getElementById(`ob_a_p_${i}`);
          const qId = document.getElementById(`ob_a_q_${i}`);
          const tId = document.getElementById(`ob_a_t_${i}`);
          pId.innerText = price;
          pId.setAttribute("title", price);
          qId.innerText = qty;
          qId.setAttribute("title", qty);
          tId.innerText = total;
          tId.setAttribute("title", total);
        });
      },
      updateSpread: (bid, ask) => {
        const { priceMaxPrecision } = Current.Terminal.Validation;
        const spread = Number(ask) - Number(bid);
        const percent = ((spread / Number(ask)) * 100).toFixed(
          priceMaxPrecision
        );
        orderBookSpread.innerText = `${percent}%`;
      },
      updateSpreadLastTrade: (lastTrade) => {
        if (!lastTrade) {
          lastTrade = Current.History.lastTrade;
        }
        const color = lastTrade.side == "buy" ? "text-success" : "text-danger";
        orderBookLast.setAttribute("class", color);
        orderBookLast.innerText = lastTrade.price;
      },
    },
  };

  // Websocket ===========================
  // cWebsocket
  const websocketConnection = document.getElementById("websocketConnection");
  const TradeWebSocket = {
    WS: null,
    readyState: 3,
    heartBeat: null,
    topics: [],
    topicToFn: {},
    init: async () => {
      TradeWebSocket.wsLoading(true);
      if (TradeWebSocket.WS) {
        await TradeWebSocket.unSubscribe();
        TradeWebSocket.subscribe();
      } else {
        TradeWebSocket.connect();
      }
    },
    connect: () => {
      try {
        const url = `wss://ws-manager-compress.bitmart.com/api?protocol=1.1`;
        const ws = new WebSocket(url);
        TradeWebSocket.WS = ws;
        TradeWebSocket.readyState = ws.readyState;
        ws.addEventListener("open", () => {
          console.log("WS Connected");
          TradeWebSocket.readyState = ws.readyState;
          TradeWebSocket.heartbeat = setInterval(TradeWebSocket.ping, 19000);
          TradeWebSocket.subscribe();
        });
        ws.addEventListener("ping", TradeWebSocket.ping);
        ws.addEventListener("close", TradeWebSocket.close);
        ws.addEventListener("message", TradeWebSocket.director);
        ws.addEventListener("error", TradeWebSocket.error);
      } catch (err) {
        TradeUtility.Page.errResponses(err);
      }
    },
    createTopics: () => {
      const { is, step } = Current.Symbol;
      const steps = {
        1: `spot/kline1m`,
        5: `spot/kline5m`,
        15: `spot/kline15m`,
        30: `spot/kline30m`,
        60: `spot/kline1H`,
        120: `spot/kline2H`,
        240: `spot/kline4H`,
        1440: `spot/kline1D`,
        10080: `spot/kline1W`,
        43200: `spot/kline1M`,
      };
      const kline = steps[step];
      TradeWebSocket.topics.push(`spot/ticker:${is}`);
      TradeWebSocket.topicToFn["spot/ticker"] = Stats.WS.update;
      TradeWebSocket.topics.push(`${kline}:${is}`);
      TradeWebSocket.topicToFn[kline] = TradingviewChart.WS.update;
      TradeWebSocket.topics.push(`spot/trade:${is}`);
      TradeWebSocket.topicToFn["spot/trade"] = TradeHistory.WS.update;
      TradeWebSocket.topics.push(`spot/depth50:${is}`);
      TradeWebSocket.topicToFn["spot/depth50"] = OrderBook.WS.update;
    },
    subscribe: () => {
      TradeWebSocket.createTopics();
      const { WS, topics, wsLoading } = TradeWebSocket;
      const subMsg = { op: "subscribe", args: topics };
      WS.send(JSON.stringify(subMsg));
      Utility.Page.loading("tradeHistoryLoading", false);
      Utility.Page.loading("orderBookAskLoading", false);
      Utility.Page.loading("orderBookBidLoading", false);
      Stats.wsLoading(false);
      wsLoading(false);
    },
    unSubscribe: async () => {
      const { topics, WS, wsLoading } = TradeWebSocket;
      wsLoading(true);
      const subMsg = { op: "unsubscribe", args: topics };
      WS.send(JSON.stringify(subMsg));
      TradeWebSocket.topics = [];
    },
    director: (msg) => {
      //console.log(new Date().toLocaleTimeString());
      //console.log(msg);
      const { topicToFn } = TradeWebSocket;
      if (msg.data !== "pong") {
        const parsed = JSON.parse(msg.data);
        const keys = Object.keys(parsed);
        if (keys.indexOf("event") == -1) {
          topicToFn[parsed.table](parsed.data);
        }
      }
    },
    close: async (msg) => {
      //console.log("closed");
      //console.log(msg);
      const { WS } = TradeWebSocket;
      TradeWebSocket.readyState = WS.readyState;
      clearInterval(TradeWebSocket.heartbeat);
      TradeWebSocket.WS = null;
    },
    ping: (msg) => {
      const { WS } = TradeWebSocket;
      TradeWebSocket.readyState = WS.readyState;
      //console.log("ping");
      WS.send("ping");
    },
    error: (msg) => {
      //console.log("err");
      //console.log(msg);
      const { WS } = TradeWebSocket;
      TradeWebSocket.readyState = WS.readyState;
      console.warn("Webhook Error");
      TradeUtility.Page.errResponses(err);
    },
    html: () => {
      const states = {
        0: { t: "Connecting", c: "text-warning" },
        1: { t: "Online", c: "text-success" },
        2: { t: "Closing", c: "text-warning" },
        3: { t: "Offline", c: "text-danger" },
      };
      const { t, c } = states[TradeWebSocket.readyState];
      websocketConnection.innerText = t;
      websocketConnection.setAttribute("class", c);
    },
    wsLoading: (isLoading) => {
      if (isLoading) {
        websocketConnection.setAttribute("class", "placeholder col");
      } else {
        TradeWebSocket.html();
      }
    },
  };

  // Utility ===========================
  const TradeUtility = {
    HTML: {
      setAttr: (arr, attr, val) => {
        arr.forEach((el) => {
          el.setAttribute(attr, val);
        });
      },
      setText: (arr, val) => {
        for (const i of arr) {
          i.innerText = val;
        }
      },
    },
    Data: {
      importLoading: false,
      userCancelImport: false,
      importFromExchange: async (importActive = true, importClosed = true) => {
        const apiExists = await Terminal.checkAPI();
        if (!apiExists) {
          const err = new Error("No API Connected. Please connect API first.");
          TradeUtility.Page.errResponses(err);
          return;
        }
        if (TradeUtility.Data.importLoading) {
          return;
        }
        const {
          importStatus,
          importingStatus,
          importingResults,
          importActiveOrders,
          importClosedTrades,
        } = TradeUtility.Data;
        TradeUtility.Data.importLoading = true;
        importStatus(true);
        const { allSymbols } = Markets;
        const symbolNames = allSymbols.map((s) => {
          return s.details.symbol;
        });
        //const symbolNames = ["BTC_USDT", "VOLT(1M)_USDT"];
        let rateLimitRemaining, rateLimitMax, rateLimitReset;
        for (let i = 0; i < symbolNames.length; i++) {
          const symbol = symbolNames[i];
          const percent = (((i + 1) / symbolNames.length) * 100).toFixed(2);
          if (TradeUtility.Data.userCancelImport) {
            importStatus();
            break;
          }
          if (Number(rateLimitRemaining) > Number(rateLimitMax)) {
            await Utility.sleep(Number(rateLimitReset) * 1010);
          }
          const results = {
            symbol,
            active: {
              status: "",
              success: false,
            },
            closed: {
              status: "",
              success: false,
            },
          };
          if (importActive) {
            try {
              const getActive = await importActiveOrders(symbol);
              results.active.status = getActive.result;
              results.active.success = true;
              rateLimitRemaining = getActive.headers.rateLimitRemaining;
              rateLimitMax = getActive.headers.rateLimitMax;
              rateLimitReset = getActive.headers.rateLimitReset;
            } catch (err) {
              results.active.status = "Failed";
              console.warn(err);
            }
          }
          if (importClosed) {
            try {
              const getClosed = await importClosedTrades(symbol);
              results.closed.status = getClosed.result;
              results.closed.success = true;
              rateLimitRemaining = getClosed.headers.rateLimitRemaining;
              rateLimitMax = getClosed.headers.rateLimitMax;
              rateLimitReset = getClosed.headers.rateLimitReset;
            } catch (err) {
              results.closed.status = "Failed";
              console.warn(err);
            }
          }
          importingResults(results);
          importingStatus(percent);
        }
        TradeUtility.Data.userCancelImport = false;
        TradeUtility.Data.importLoading = false;
        setTimeout(importStatus, 5000);
      },
      cancelImport: (event) => {
        const { importStatus } = TradeUtility.Data;
        if (TradeUtility.Data.importLoading) {
          TradeUtility.Data.userCancelImport = true;
        } else {
          importStatus();
        }
      },
      clearSheet: () => {
        return new Promise((resolve, reject) => {
          Utility.Server.run()
            .withSuccessHandler((result) => {
              resolve();
            })
            .withFailureHandler((err) => {
              reject(err);
            })
            .clearSheet();
        });
      },
      importActiveOrders: async (symbol) => {
        return new Promise((resolve, reject) => {
          Utility.Server.run()
            .withSuccessHandler((result) => {
              resolve(result);
            })
            .withFailureHandler((err) => {
              reject(err);
            })
            .importActive(symbol);
        });
      },
      importClosedTrades: async (symbol) => {
        return new Promise((resolve, reject) => {
          Utility.Server.run()
            .withSuccessHandler((result) => {
              resolve(result);
            })
            .withFailureHandler((err) => {
              reject(err);
            })
            .importClosed(symbol);
        });
      },
      importingStatus: (percent) => {
        const progress = document.getElementById("importProgress");
        progress.style.width = `${percent}%`;
        progress.innerText = `${percent}%`;
        if (percent < 1) {
          progress.setAttribute(
            "class",
            "progress-bar bg-dark progress-bar-striped progress-bar-animated"
          );
        }
        if (percent == 100) {
          setTimeout(() => {
            progress.setAttribute(
              "class",
              "progress-bar bg-success progress-bar-striped progress-bar-animated"
            );
          }, 1000);
        }
      },
      importingResults: (results) => {
        const body = document.getElementById("importResults");
        const div = document.createElement("div");
        const active = document.createElement("span");
        const closed = document.createElement("span");
        const divider = document.createElement("span");
        const symbol = document.createElement("h6");
        symbol.innerText = `${results.symbol}:`;
        symbol.setAttribute("class", "mb-0");
        active.innerText = `Active: ${results.active.status}`;
        closed.innerText = `Closed: ${results.closed.status}`;
        divider.innerText = ` || `;
        const check = `
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              fill="currentColor"
              class="bi bi-check2-circle text-success"
              viewBox="0 0 16 16"
              >
              <path
                d="M2.5 8a5.5 5.5 0 0 1 8.25-4.764.5.5 0 0 0 .5-.866A6.5 6.5 0 1 0 14.5 8a.5.5 0 0 0-1 0 5.5 5.5 0 1 1-11 0z"
              />
              <path
                d="M15.354 3.354a.5.5 0 0 0-.708-.708L8 9.293 5.354 6.646a.5.5 0 1 0-.708.708l3 3a.5.5 0 0 0 .708 0l7-7z"
              />
            </svg>
            `;
        const X = `
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              fill="currentColor"
              class="bi bi-x-circle text-danger"
              viewBox="0 0 16 16"
            >
              <path
                d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"
              />
              <path
                d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"
              />
            </svg>
            `;

        const activeSvg = document.createElement("span");
        const closedSvg = document.createElement("span");
        activeSvg.innerHTML = results.active.success ? check : X;
        closedSvg.innerHTML = results.closed.success ? check : X;
        div.append(symbol);
        div.append(active);
        div.append(activeSvg);
        div.append(divider);
        div.append(closed);
        div.append(closedSvg);
        body.prepend(div);
      },
      importStatus: (onOff = false) => {
        const importToast = document.getElementById("importToast");
        const body = document.getElementById("importResults");
        body.innerHTML = "";
        const toast = new bootstrap.Toast(importToast);
        if (onOff) {
          toast.show();
        } else {
          toast.hide();
        }
      },
    },
    Webhook: {
      clearInput: () => {
        document.getElementById("setWebhookUrl").value = "";
      },
      checkInputs: () => {
        const input = document.getElementById("setWebhookUrl");
        const URL = input.value.trim();
        if (URL.includes(`https://discord.com/api/webhooks/`)) {
          input.setAttribute("class", "form-control is-valid");
          return URL;
        } else {
          input.setAttribute("class", "form-control is-invalid");
          return false;
        }
      },
      save: async () => {
        const apiExists = await Terminal.checkAPI();
        if (!apiExists) {
          const err = new Error("No API Connected. Please connect API first.");
          TradeUtility.Page.errResponses(err);
          return;
        }
        const check = TradeUtility.Webhook.checkInputs();
        if (check) {
          const id = document.getElementById("saveWebhookResults");
          Utility.Page.loading("saveWebhookResults", true, "start");
          Utility.Server.run()
            .withSuccessHandler(() => {
              Utility.Page.loading("saveWebhookResults", false);
              Utility.Page.showSuccessAlert(id);
              TradeUtility.Webhook.clearInput();
            })
            .withFailureHandler((err) => {
              Utility.Page.loading("saveWebhookResults", false);
              Utility.Page.showFailureAlert(id, err);
            })
            .saveWebhook(check);
        }
      },
      delete: () => {
        const id = document.getElementById("saveWebhookResults");
        Utility.Page.loading("saveWebhookResults", true, "start");
        Utility.Server.run()
          .withSuccessHandler(() => {
            Utility.Page.loading("saveWebhookResults", false);
            Utility.Page.showSuccessAlert(id);
          })
          .withFailureHandler((err) => {
            Utility.Page.loading("saveWebhookResults", false);
            Utility.Page.showFailureAlert(id, err);
          })
          .deleteWebhook();
      },
    },
    API: {
      clearInputs: () => {
        const memoID = document.getElementById("setAPIMemo");
        const keyID = document.getElementById("setAPIKey");
        const secretID = document.getElementById("setAPISecret");
        memoID.setAttribute("class", "form-control is-invalid");
        memoID.value = "";
        keyID.setAttribute("class", "form-control is-invalid");
        keyID.value = "";
        secretID.setAttribute("class", "form-control is-invalid");
        secretID.value = "";
      },
      clearClipboard: () => {
        navigator.clipboard.writeText("");
      },
      checkInputs: () => {
        const memoID = document.getElementById("setAPIMemo");
        const memo = memoID.value.trim();
        if (!memo.length) {
          memoID.setAttribute("class", "form-control is-invalid");
        } else {
          memoID.setAttribute("class", "form-control is-valid");
        }
        const keyID = document.getElementById("setAPIKey");
        const key = keyID.value.trim();
        if (key.length !== 40) {
          keyID.setAttribute("class", "form-control is-invalid");
        } else {
          keyID.setAttribute("class", "form-control is-valid");
        }
        const secretID = document.getElementById("setAPISecret");
        const secret = secretID.value.trim();
        if (secret.length !== 64) {
          secretID.setAttribute("class", "form-control is-invalid");
        } else {
          secretID.setAttribute("class", "form-control is-valid");
        }
      },
      save: () => {
        const memo = document.getElementById("setAPIMemo").value.trim();
        const key = document.getElementById("setAPIKey").value.trim();
        const secret = document.getElementById("setAPISecret").value.trim();
        if (!memo && !key && !secret) {
          TradeUtility.API.checkInputs();
          return;
        }
        if (key.length !== 40) {
          return;
        }
        if (secret.length !== 64) {
          return;
        }
        const id = document.getElementById("saveAPIResults");
        Utility.Page.loading("saveAPIResults", true, "start");
        Utility.Server.run()
          .withSuccessHandler(() => {
            Utility.Page.loading("saveAPIResults", false);
            Utility.Page.showSuccessAlert(id);
            TradeUtility.API.clearInputs();
            TradeUtility.API.clearClipboard();
            Terminal.init();
          })
          .withFailureHandler((err) => {
            Utility.Page.loading("saveAPIResults", false);
            Utility.Page.showFailureAlert(id, err);
          })
          .saveAPI(memo, key, secret);
      },
      remove: () => {
        const id = document.getElementById("saveAPIResults");
        Utility.Page.loading("saveAPIResults", true, "start");
        Utility.Server.run()
          .withSuccessHandler(() => {
            Utility.Page.loading("saveAPIResults", false);
            Utility.Page.showSuccessAlert(id);
            Terminal.Form.Util.clear();
            Terminal.Form.Util.disable();
          })
          .withFailureHandler((err) => {
            Utility.Page.loading("saveAPIResults", false);
            Utility.Page.showFailureAlert(id, err);
          })
          .deleteAPI();
      },
    },
    Page: {
      markerTime: (originalTime) => {
        const d = new Date(originalTime);
        const { step } = Current.Symbol;
        let UTC;
        switch (step) {
          case 1:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours(),
              d.getMinutes()
            );
            break;

          case 5:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours(),
              d.getMinutes() - 5
            );
            break;

          case 15:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours(),
              d.getMinutes() - 15
            );
            break;

          case 30:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours(),
              d.getMinutes() - 30
            );
            break;

          case 60:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours()
            );
            break;
          case 120:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours() - 2
            );
            break;
          case 240:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours() - 4
            );
            break;
          case 1440:
            UTC = Date.UTC(d.getFullYear(), d.getMonth(), d.getDate());
            break;
          case 10080:
            UTC = Date.UTC(d.getFullYear(), d.getMonth(), d.getDate() - 6);
            break;
          case 43200:
            UTC = Date.UTC(d.getFullYear(), d.getMonth());
            break;

          default:
            break;
        }
        return UTC / 1000;
      },
      forUpdateTime: (originalTime) => {
        const d = new Date(originalTime * 1000);
        const UTC = Date.UTC(
          d.getFullYear(),
          d.getMonth(),
          d.getDate(),
          d.getHours()
          //d.getMinutes() - 1
        );
        return UTC / 1000;
      },
      toLocalTime: (originalTime, isUpdate = false) => {
        const d = new Date(originalTime * 1000);
        const { step } = Current.Symbol;
        let UTC;
        switch (step) {
          case 1:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours(),
              isUpdate ? d.getMinutes() : d.getMinutes() - 1
            );
            break;

          case 5:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours(),
              isUpdate ? d.getMinutes() : d.getMinutes() - 5
            );
            break;

          case 15:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours(),
              isUpdate ? d.getMinutes() : d.getMinutes() - 15
            );
            break;

          case 30:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              d.getHours(),
              isUpdate ? d.getMinutes() : d.getMinutes() - 30
            );
            break;

          case 60:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              isUpdate ? d.getHours() : d.getHours() - 1
            );
            break;
          case 120:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              isUpdate ? d.getHours() : d.getHours() - 2
            );
            break;
          case 240:
            UTC = Date.UTC(
              d.getFullYear(),
              d.getMonth(),
              d.getDate(),
              isUpdate ? d.getHours() : d.getHours() - 4
            );
            break;
          case 1440:
            UTC = Date.UTC(d.getFullYear(), d.getMonth(), d.getDate());
            break;
          case 10080:
            UTC = Date.UTC(d.getFullYear(), d.getMonth(), d.getDate() - 6);
            break;
          case 43200:
            UTC = Date.UTC(d.getFullYear(), d.getMonth());
            break;

          default:
            break;
        }
        return UTC / 1000;
      },
      openSpreadsheet: () => {
        Utility.Server.run()
          .withSuccessHandler((result) => {
            window.open(result, "_blank");
          })
          .withFailureHandler((err) => {})
          .ID();
      },
      // cEvent
      addEventListeners: () => {
        const listeners = {
          Resize: [
            {
              id: null,
              w: window,
              cl: null,
              fn: TradingviewChart.Html.Chart.create,
              type: "resize",
            },
          ],
          Import: [
            {
              id: "startInitialImportAll",
              w: null,
              cl: null,
              fn: TradeUtility.Data.importFromExchange,
              type: "click",
            },
            {
              id: "startInitialImportActive",
              w: null,
              cl: null,
              fn: () => {
                TradeUtility.Data.importFromExchange(true, false);
              },
              type: "click",
            },
            {
              id: "startInitialImportClosed",
              w: null,
              cl: null,
              fn: () => {
                TradeUtility.Data.importFromExchange(false, true);
              },
              type: "click",
            },
            {
              id: "cancelInitialImport",
              w: null,
              cl: null,
              fn: TradeUtility.Data.cancelImport,
              type: "click",
            },
          ],
          Spreadsheet: [
            {
              id: "openSpreadsheet",
              w: null,
              cl: null,
              fn: TradeUtility.Page.openSpreadsheet,
              type: "click",
            },
          ],
          API: [
            {
              id: ["setAPIMemo", "setAPIKey", "setAPISecret"],
              w: null,
              cl: null,
              fn: TradeUtility.API.checkInputs,
              type: "keyup",
            },
            {
              id: ["setAPIMemo", "setAPIKey", "setAPISecret"],
              w: null,
              cl: null,
              fn: TradeUtility.API.checkInputs,
              type: "paste",
            },
            {
              id: "closeAPIInfo",
              w: null,
              cl: null,
              fn: TradeUtility.API.clearInputs,
              type: "click",
            },
            {
              id: "saveAPIInfo",
              w: null,
              cl: null,
              fn: TradeUtility.API.save,
              type: "click",
            },
            {
              id: "deleteAPIInfo",
              w: null,
              cl: null,
              fn: TradeUtility.API.remove,
              type: "click",
            },
          ],
          Webhook: [
            {
              id: "saveWebhook",
              w: null,
              cl: null,
              fn: TradeUtility.Webhook.save,
              type: "click",
            },
            {
              id: "deleteWebhook",
              w: null,
              cl: null,
              fn: TradeUtility.Webhook.delete,
              type: "click",
            },
            {
              id: "setWebhookUrl",
              w: null,
              cl: null,
              fn: TradeUtility.Webhook.checkInputs,
              type: "keyup",
            },
            {
              id: "setWebhookUrl",
              w: null,
              cl: null,
              fn: TradeUtility.Webhook.checkInputs,
              type: "paste",
            },
          ],
          Markets: [
            {
              id: "focusSearch",
              w: null,
              cl: null,
              fn: Markets.Nav.User.focus,
              type: "click",
            },
            {
              id: null,
              w: null,
              cl: searchMarketsInput,
              fn: Markets.Nav.User.input,
              type: "keyup",
            },
            {
              id: null,
              w: null,
              cl: selectMarketQuote,
              fn: Markets.Nav.User.SelectNavPage.whenClicked,
              type: "click",
            },
            {
              id: ["sortByMarket", "sortByChange", "sortByPrice"],
              w: null,
              cl: null,
              fn: Markets.Nav.Sort.whenClicked,
              type: "click",
            },
            {
              id: null,
              w: null,
              cl: marketsList,
              fn: Markets.Nav.User.clickNavList,
              type: "click",
            },
          ],
          Chart: [
            {
              id: null,
              w: null,
              cl: chooseChartStep,
              fn: TradingviewChart.Data.updateStep,
              type: "change",
            },
            {
              id: null,
              w: null,
              cl: chooseCandleSets,
              fn: TradingviewChart.Data.updateSets,
              type: "change",
            },
            // Markers
            {
              id: ["toggleMarkers", "toggleMarkerPrices"],
              w: null,
              cl: null,
              fn: TradingviewChart.Html.Markers.toggle,
              type: "click",
            },

            //Lines
            {
              id: [
                "toggleActive",
                "toggleLineSymbol",
                "toggleLineSize",
                "toggleScreenshotMode",
                "toggleShowTp",
              ],
              w: null,
              cl: null,
              fn: TradingviewChart.Html.Lines.Active.toggle,
              type: "click",
            },
          ],
          Orders: [
            {
              id: ["viewActiveOrders", "viewClosedOrders", "viewWallets"],
              w: null,
              cl: null,
              fn: Orders.Nav.changeView,
              type: "click",
            },
            {
              id: "activeOrdersTable",
              w: null,
              cl: null,
              fn: Orders.User.OpenOrders.cancel,
              type: "click",
            },
            {
              id: "activeOrdersTable",
              w: null,
              cl: null,
              fn: Orders.User.OpenOrders.hover,
              type: "mouseover",
            },
            {
              id: "activeOrdersTable",
              w: null,
              cl: null,
              fn: Orders.User.OpenOrders.hover,
              type: "mouseout",
            },
            {
              id: [
                "cancelAllActive",
                "cancelBuyActive",
                "cancelSellActive",
                "cancelAllSelected",
              ],
              w: null,
              cl: null,
              fn: Orders.User.OpenOrders.cancelAll,
              type: "click",
            },
          ],
          Terminal: [
            // Wallet
            {
              id: "getAvailableQuote",
              w: null,
              cl: null,
              fn: Terminal.Wallet.getAvailable,
              type: "click",
            },
            // Simple
            // -Click
            {
              id: [
                "selectSimpleBuyOrder",
                "selectSimpleSellOrder",
                "simpleApproxBase",
                "simpleApproxQuote",
              ],
              w: null,
              cl: null,
              fn: Terminal.Form.Simple.runHtml,
              type: "click",
            },
            // -Change
            {
              id: ["simpleTradeType", "simpleOrderType", "simpleFundingSrc"],
              w: null,
              cl: null,
              fn: Terminal.Form.Simple.runHtml,
              type: "change",
            },
            // -Focus
            {
              id: ["simplePriceA", "simplePriceB"],
              w: null,
              cl: null,
              fn: Terminal.Form.Simple.runHtml,
              type: "focus",
            },
            {
              id: ["simpleApproxBase", "simpleApproxQuote"],
              w: null,
              cl: null,
              fn: Terminal.Form.Simple.runHtml,
              type: "keydown",
            },
            // -Submit
            {
              id: "simpleForm",
              w: null,
              cl: null,
              fn: Terminal.Form.Simple.submitSimpleOrder,
              type: "submit",
            },
            // -Calc
            {
              id: [
                "simplePriceA",
                "simplePriceB",
                "simpleVolCustom",
                "simpleTotal",
              ],
              w: null,
              cl: null,
              fn: Terminal.Form.Simple.runCalc,
              type: "keydown",
            },
            {
              id: [
                "simpleTradeType",
                "simpleOrderType",
                "simpleFundingType",
                "simpleFundingSrc",
                "simpleNumOrders",
              ],
              w: null,
              cl: null,
              fn: Terminal.Form.Simple.runCalc,
              type: "change",
            },
            {
              id: ["selectSimpleBuyOrder", "selectSimpleSellOrder"],
              w: null,
              cl: null,
              fn: Terminal.Form.Simple.runCalc,
              type: "click",
            },
            {
              id: null,
              w: null,
              cl: volShortcut,
              fn: Terminal.Form.Simple.Inputs.simpleCustomPreset.calc,
              type: "click",
            },

            // Smart
            // -Click
            {
              id: [
                "selectSmartBuyOrder",
                "selectSmartSellOrder",
                "smartApproxBase",
                "smartApproxQuote",
              ],
              w: null,
              cl: null,
              fn: Terminal.Form.Smart.runHtml,
              type: "click",
            },
            // -Change
            {
              id: ["smartTradeType", "smartOrderType", "smartFundingSrc"],
              w: null,
              cl: null,
              fn: Terminal.Form.Smart.runHtml,
              type: "change",
            },
            // -Focus
            {
              id: ["smartPriceA", "smartPriceB"],
              w: null,
              cl: null,
              fn: Terminal.Form.Smart.runHtml,
              type: "focus",
            },
            {
              id: ["smartApproxBase", "smartApproxQuote"],
              w: null,
              cl: null,
              fn: Terminal.Form.Smart.runHtml,
              type: "keydown",
            },
            // -Submit
            {
              id: "smartForm",
              w: null,
              cl: null,
              fn: Terminal.Form.Smart.submitSmartOrder,
              type: "submit",
            },
            // -Calc
            {
              id: [
                "smartPriceA",
                "smartPriceB",
                "smartTpCustom",
                "smartTP",
                "smartVolCustom",
                "smartTotal",
              ],
              w: null,
              cl: null,
              fn: Terminal.Form.Smart.runCalc,
              type: "keydown",
            },
            {
              id: [
                "smartTradeType",
                "smartOrderType",
                "smartFundingType",
                "smartFundingSrc",
                "smartNumOrders",
              ],
              w: null,
              cl: null,
              fn: Terminal.Form.Smart.runCalc,
              type: "change",
            },
            {
              id: ["selectSmartBuyOrder", "selectSmartSellOrder"],
              w: null,
              cl: null,
              fn: Terminal.Form.Smart.runCalc,
              type: "click",
            },
            {
              id: null,
              w: null,
              cl: volShortcut,
              fn: Terminal.Form.Smart.Inputs.smartCustomPreset.calc,
              type: "click",
            },
            {
              id: null,
              w: null,
              cl: tpShortcut,
              fn: Terminal.Form.Smart.Inputs.smartTpPreset.calc,
              type: "click",
            },

            // Clear
            {
              id: ["clearSimpleForm", "clearSmartForm"],
              w: null,
              cl: null,
              fn: Terminal.Form.Util.clear,
              type: "click",
            },
            // Switch
            {
              id: "selectTradeCategory",
              w: null,
              cl: null,
              fn: Terminal.Form.switch,
              type: "change",
            },
          ],
          TradeHistory: [
            {
              id: "tradeHistoryTable",
              w: null,
              cl: null,
              fn: TradeHistory.User.onClick,
              type: "click",
            },
          ],
          OrderBook: [
            {
              id: ["askOrderBookTable", "bidOrderBookTable"],
              w: null,
              cl: null,
              fn: OrderBook.User.onClick,
              type: "click",
            },
          ],
        };

        for (const key in listeners) {
          if (Object.hasOwnProperty.call(listeners, key)) {
            const listenerArray = listeners[key];
            listenerArray.forEach((l) => {
              const { id, w, cl, fn, type } = l;
              let getElementId;
              try {
                if (id) {
                  if (Array.isArray(id)) {
                    id.forEach((i) => {
                      getElementId = document.getElementById(i);
                      getElementId.addEventListener(type, fn);
                    });
                  } else {
                    getElementId = document.getElementById(id);
                    getElementId.addEventListener(type, fn);
                  }
                } else if (cl) {
                  for (const el of cl) {
                    el.addEventListener(type, fn);
                  }
                } else if (w) {
                  window.addEventListener(type, fn);
                }
              } catch (err) {
                console.error(id, err);
              }
            });
          }
        }
      },
      errResponses: (err) => {
        const tryParse = (msg) => {
          try {
            JSON.parse(msg);
            return true;
          } catch (err) {
            return false;
          }
        };
        let msg;
        if (tryParse(err.message)) {
          const text = JSON.parse(err.message);
          const errorMessage = text.result.message;
          msg =
            `<p><strong>Message:</strong><div>${
              typeof errorMessage == "string"
                ? errorMessage
                : JSON.stringify(errorMessage, null, "\t")
            }</div></p>` + `<p><strong>Where:</strong>${text.where}</p>`;
        } else {
          try {
            msg =
              `<p><strong>Message:</strong><div>${err}</div></p>` +
              `<p><strong>Where:</strong> ${err.stack
                .split("\n")
                .reduce((t, el) => {
                  return (t += `<div>${el}</div>`);
                }, "")}</p>`;
          } catch (error) {
          } finally {
            msg =
              `<p><strong>Message:</strong><div>${err}</div></p>` +
              `<p><strong>Where:</strong> ${err.stack}</p>`;
          }
        }
        const toastContainer = document.getElementById("toasts");
        const div = document.createElement("div");
        const time = new Date().getTime();
        const toastHtml = `
            <div
                class="toast bg-dark border border-danger"
                data-bs-autohide="false"
                role="alert"
                aria-live="assertive"
                aria-atomic="true"
                id="currentToast_${time}"
              >
                <div class="toast-header bg-danger">
                  <strong class="me-auto text-dark">Error</strong>
                  <button
                    type="button"
                    class="btn-close"
                    data-bs-dismiss="toast"
                    aria-label="Close"
                  ></button>
                </div>
                <div class="toast-body text-light">${msg}</div>
            </div>
            `;
        div.innerHTML = toastHtml;
        toastContainer.append(div);
        const currentToast = document.getElementById(`currentToast_${time}`);
        const toast = new bootstrap.Toast(currentToast);
        toast.show();
        console.warn(err, err.message, err.stack);
      },
    },
  };
</script>
